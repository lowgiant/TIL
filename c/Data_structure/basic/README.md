#Data Structure Basic

## 01-자료구조 개요
### 1. 필요성
- 데이터를 효과적으로 저장
- 메모리와 성능 낭비 줄이기
### 2. 종류
1. 선형구조 
    - 배열
    - 연결리스트
    - 스택
    - 큐
2. 비선형구조
    - 트리
    - 그래프
### 3. 성능측정
   > 효율적인 알고리즘은 시간과 공간은 `반비례 관계`  
1. 시간복잡도: 알고리즘에 사용되는 `연산 횟수`
   - Big-O 표기법: 시간복잡도에서 `최악의 경우`
       > for 문의 중첩이 될때마 `제곱`으로 늘어남
2. 공간복잡도: 알고리즘에 사용되는 `메모리의 양`
   - 일반적으로 MB 단위로 표기
      ```c
      int a[1000]:       4KB
      int a[1000000]:    4MB
      int a[2000][2000]:16MB
      ```

## 02-리스트
### 1. 배열 기반리스트
- 특정한 위치의 원소에 즉시 접근 할 수 있음
- 데이터가 들어갈 공간 미리 메모리에 `할당`해야함
- 원하는 위치로 삽입이나 삭제 `비효율`
### 2. 연결 리스트
- 삽입 및 삭제가 배열에 비해 `간단함`
- 특정 인덱스 즉시 접근 하지 못함
- 원소 차례대로 검색해야함
- 추가적인 포인터 변수가 사용돼 메모리 공간 낭비

## 03-양방향 연결 리스트
### 1. 특징
- 머리와 꼬리를 가짐
- 각 노드 앞 노드와 뒤 노드의 정보를 모두 저장

### 2. 구현시 주의할 점
- 삽입 및 삭제 기능 개발시 `예외 처리` 필요
- 예: 삭제할 원소가 없는데 삭제해야 하는 경우

## 04-스택 및 큐
### 1. 스택
- 한쪽으로 들어가서 한쪽으로 나오는 자료구조
- PUSH: 스택에서 데이터 넣기
- POP: 스택에서 데이터 빼기

### 2. 큐
- 뒤쪽으로 들어가서 앞쪽으로 나오는 자료구조

## 05-정렬
### 1. 선택정렬
   - `가장 작은 것`을 `선택해 앞`으로 보내는 정렬
   - 시간복잡도: O(N<sup>2</sup>)
### 2. 삽입정렬
   - 각 숫자를 적절한 `위치`에 `삽입`하는 정렬 
   - 시간복잡도: O(N<sup>2</sup>) 
### 3. 퀵정렬
   - `피벗`을 기준으로 `큰 값`과 `작은 값`을 서로 교체하는 정렬
   - 시간복잡도: O(NlogN)
### 4. 계수정렬
   - 크기를 기준으로 데이터 개수를 세는 정렬
   - 시간복잡도: O(N)
### 5. 기수정렬
   - 자릿수를 기준으로 차례대로 데이터 정렬
   - 계수정렬 보다 약간 느림
   - 숫자가 매우 큰 상황에서도 사용 가능
   - O(DN)

## 06-이진트리
- 순회 알고리즘에 사용
- 나무의 형태를 뒤집은 것과 같음
- 많은 양의 노드를 낮은 높이에서 관리 할 수 있음
- 데이터 활용의 `효율성` 높아짐
- 데이터 저장, 탐색등의 목적 가짐

### 1. 구현
- 부모 밑 왼쪽자식 오른쪽 자식 존재

### 2. 순회
1. 전위순회
   1. 자기 자신 출력
   2. 왼쪽 자식 방문
   3. 오른쪽 자식 방문
2. 중위순회
   1. 왼쪽 자식 방문
   2. 자기 자신을 출력
   3. 오른쪽 자식 방문
3. 후위순회
   1. 왼쪽 자식 방문
   2. 오른쪽 자식 방문
   3. 자기 자신 출력

## 07-AVL트리
### 1. 특징
   - 균형이 갖춰진 이진 트리
   - 시간복잡도: O(logN)
   - 모든 노드에 균형 인수가 +1, 0, -1인 트리를 의미
   - 균형인수가 위 세가지 경우에 해당이 안되면 `회전`을 통해 트리를 재구성

## 08-해시
### 1. 특징
   - `특정한 값`을 찾고자 할때 그 값의 `키`로 접근
   - 데이터를 `최대한 빠른 속도`로 관리하도록 도와주는 자료구조
   - `메모리 공간`은 많이 소모
   - 데이터베이스 및 정보보안 관련 모듈 등에 활용
   - 시간복잡도: O(1)
### 2. 충돌
   - 해시 함수의 입력값은 어떠한 값이나 모두 들어갈 수 있음
   - 키 중복이 발생할 때 충돌(collision)라 표현
   1. 처리방법
      1. 충돌 발생시 `다른위치로 저장`: 선형 조사법, 이차 조사법 
      2. 하나의 버킷에 여러개의 항목을 저장: `체이닝` 등
### 3. 해싱
   - 나눗셈 법이 가장 많이 활용
   - 입력 값을 테이블의 크기로 `나눈 나머지`를 키로 이용
   - 테이블의 크기는 `소수`(Prime Number)로 설정해야 `효율성 높음`

## 09-알고리즘
### 1. 프림 알고리즘
   1. 신장 트리
      - 신장 트리: 특정한 그래프에 모든 정점을 포함한 그래프
      - 최소 신장 트리: 스패닝 트리 중 `간선`의 `가중치 합`이 `가장 작은 트리`
   2. 구현
      1. 그래프에 정점 하나 선택해 트리 T 포함
      2. T에 포함된 노드와 T에 포함되지 않은 노드 사이의 간선 중에서 가중치가 가장 작은 간선을 찾음
      3. 해당 간선에 연결된 T에 포함되지 않은 노드를 트리 T에 포함
      4. 모든 노드가 포함 될때 까지 2~3번 과정 반복 
   3. 시간복잡도
      - 최소 스패닝 트리 구하는 과정 O(ELogV)
### 2. 다익스트라의 최단 경로
   1. 특징
      - `각 간선`에 대한 정보를 `우선순위 큐`에 담아 처리하는 방식이 `프림 알고리즘`과 흡사
      - 현실 세계에 적합한 알고리즘(음의 간선이 존재하지 않기 때문)
   2. 구현
      1. 그래프 시작점을 선택해 트리 T에 포함
      2. T에 포함된 노드와 T에 포함되지 않은 노드 사이의 간선 중에서 `이동 거리`가 가장 작은 간선 찾음
      3. 해당 간선에 연결된 T에 포함되지 않은 노드를 트리 T에 포함
      4. 모든 노드가 포함될 때까지 2~3번 과정 반복
   3. 시간복잡도
      - O(ELogV)
### 3. 세그먼트 트리
1. 특징
   - 여러  개의 데이터가 `연속적`으로 존재할 때 특정한 범위의 `데이터 합`
   - 구현과정 복잡 
   - 선형적은 트리구조 보다 비효율적
2. 시간복잡도
   - `선형적` 구간 합 과정: O(N)
   - `트리` 구조 구간합 및 `원소 수정`: O(logN)
### 4. 인덱스 트리
1. 특징
   - 구현이 간단함
   - 세그먼트 트리 보다 `메모리 효율성 높음`
2. 시간복잡도
   - 인덱스 트리 활용: O(logN)
### 5. 문자열 매칭
1. 특징
   1. 단순 비교 문자열 매칭: 
      - 문자열 A에서 B를 찾는 과정
   2. KMP 문자열 매칭
      - `접두사`와 `접미사`를 활용해 빠르게 문자 매칭
   3. 라빈 카프 문자열 매칭
      - `해시 함수`을 이용해 특정한 문자열에 대한 해시값 구함
      - 각 문자의 아스키 코드 값에 `2의 제곱 수`를 차례대로 곱해 더한 값
2. 시간복잡도
   1. 단순 비교 문자열 매칭: `O(NM)`
   2. KMP 문자열 매칭: `O(N+M)`
   3. 라빈 카프 문자열 매칭: `O(N+M)` 
      >연속적인 문자열: `O(1)` 
