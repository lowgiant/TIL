#Data Structure Basic

## 01-자료구조 개요
1. 필요성
    - 데이터를 효과적으로 저장
    - 메모리와 성능 낭비 줄이기
2. 종류
    1. 선형구조 
        - 배열
        - 연결리스트
        - 스택
        - 큐
    2. 비선형구조
        - 트리
        - 그래프
3. 성능측정
   > 효율적인 알고리즘은 시간과 공간은 `반비례 관계`  
    1. 시간복잡도: 알고리즘에 사용되는 `연산 횟수`
       - Big-O 표기법: 시간복잡도에서 `최악의 경우`
         > for 문의 중첩이 될때마 `제곱`으로 늘어남
    2. 공간복잡도: 알고리즘에 사용되는 `메모리의 양`
       - 일반적으로 MB 단위로 표기
            ```c
            int a[1000]:       4KB
            int a[1000000]:    4MB
            int a[2000][2000]:16MB
            ```

## 02-리스트
 1. 배열 기반리스트
     - 특정한 위치의 원소에 즉시 접근 할 수 있음
     - 데이터가 들어갈 공간 미리 메모리에 `할당`해야함
     - 원하는 위치로 삽입이나 삭제 `비효율`
 2. 연결 리스트
     - 삽입 및 삭제가 배열에 비해 `간단함`
     - 특정 인덱스 즉시 접근 하지 못함
     - 원소 차례대로 검색해야함
     - 추가적인 포인터 변수가 사용돼 메모리 공간 낭비

## 03-양방향 연결 리스트
1. 특징
    - 머리와 꼬리를 가짐
    - 각 노드 앞 노드와 뒤 노드의 정보를 모두 저장

2. 구현시 주의할 점
    - 삽입 및 삭제 기능 개발시 `예외 처리` 필요
    - 예: 삭제할 원소가 없는데 삭제해야 하는 경우

## 04-스택 및 큐
1. 스택
    - 한쪽으로 들어가서 한쪽으로 나오는 자료구조
    - PUSH: 스택에서 데이터 넣기
    - POP: 스택에서 데이터 빼기

2. 큐
    - 뒤쪽으로 들어가서 앞쪽으로 나오는 자료구조

## 05-정렬
1. 선택정렬
   - `가장 작은 것`을 `선택해 앞`으로 보내는 정렬
   - 시간복잡도: O(N<sup>2</sup>)
2. 삽입정렬
   - 각 숫자를 적절한 `위치`에 `삽입`하는 정렬 
   - 시간복잡도: O(N<sup>2</sup>) 
3. 퀵정렬
   - `피벗`을 기준으로 `큰 값`과 `작은 값`을 서로 교체하는 정렬
   - 시간복잡도: O(NlogN)
4. 계수정렬
   - 크기를 기준으로 데이터 개수를 세는 정렬
   - 시간복잡도: O(N)
5. 기수정렬
   - 자릿수를 기준으로 차례대로 데이터 정렬
   - 계수정렬 보다 약간 느림
   - 숫자가 매우 큰 상황에서도 사용 가능
   - O(DN)

## 06-이진트리
- 순회 알고리즘에 사용
- 나무의 형태를 뒤집은 것과 같음
- 많은 양의 노드를 낮은 높이에서 관리 할 수 있음
- 데이터 활용의 `효율성` 높아짐
- 데이터 저장, 탐색등의 목적 가짐

1. 구현
- 부모 밑 왼쪽자식 오른쪽 자식 존재

2. 순회
    1. 전위순회
       1. 자기 자신 출력
       2. 왼쪽 자식 방문
       3. 오른쪽 자식 방문
    2. 중위순회
       1. 왼쪽 자식 방문
       2. 자기 자신을 출력
       3. 오른쪽 자식 방문
    3. 후위순회
       1. 왼쪽 자식 방문
       2. 오른쪽 자식 방문
       3. 자기 자신 출력

## 07-AVL트리
1. 특징
   - 균형이 갖춰진 이진 트리
   - 시간복잡도: O(logN)
   - 모든 노드에 균형 인수가 +1, 0, -1인 트리를 의미
   - 균형인수가 위 세가지 경우에 해당이 안되면 `회전`을 통해 트리를 재구성