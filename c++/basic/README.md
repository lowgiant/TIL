# C++ basic

## 01-C와 C++ 비교
### -  차이점
   C | C++
   :---: | :---:
   절차지향 | 객체지향
   함수 | 객체 중심
   구조체 | 클래스
   stdio.h | iostream
   공백문자 | >>
   char arr[SIZE] | string s;
   malloc | new
   free | delete 
   printf | cout
   \n | endl

## 02-클래스
### 1. 특징
   - 객체를 프로그램 내에서 구현해 소스코드 간결함
   - 추상화, 캡슐화, 상속성
   - 정보은닉, 다형성
### 2. 멤버
   - 멤버 변수: `속성`, `프로퍼티`라고 부름
   - 멤버 함수: `메소드`라고도 부름
### 3. 인스턴스
   - 프로그램 상에서 객체가 살아서 동작하도록 함
   - 하나의 클래스에 여러개의 서로 다른 인스턴스를 만들 수 있음
### 4. 접근 한정자
   - 클래스는 기본적으로 멤버를 `private` 형태로 간주
   - 구조체는 기본적으로 멤버를 `public` 형태로 간주
   - 클래스 내부에서 `정의된` 멤버 함수를 불러 올때 멤버 참조 연산자(.)를 사용해 불러옴
   1. public: 클래스, 멤버 등 외부로 `공개`
      > 해당 객체를 사용하는 어떤 곳에서 접근 가능
   2. private: 클래스, 멤버 등 내부에서만 활용
      > 외부에서 해당 객체 접근 할 수 없음
### 5. this 포인터
1. 하나의 클래스에서 생성된 인스턴스는 `서로 독립된 메모리 영역`에 멤버 변수를 저장
2. this 포인터는 `포인터`자료형으로, `상수`라는 점에서 값을 변경 할 수 없음

## 03-생성자와 소멸자
### 1. 생성자
1. 특징
   - 객체를 생성함, 멤버 변수 초기화
   - 클래스의 이름과 `동일한 메소드`로 현현
   - 반환 값 없음
   - 여러번 정의돼 다양한 방법으로 객체를 초기화 할 수 있음
2. 기본 생성자
   - 매개변수를 가지지 않음
   - 멤버 변수 `O, NULL`의 값 초기화
3. 복사 생성자
   - 다른 인스턴스의 참조를 인수 받아 그 참조를 이용해 자신의 인스턴스 초기화
   - `깊은 복사`를 이용해 만들어진 인스턴스는 기존의 인스턴스와 다른 메모리 공간에 할당돼 `독립적`
### 2. 소멸자
1. 특징
   - 객체의 수명이 끝났을 때 객체를 제거하기 위한 목적으로 사용
   - 수명이 끝난 객체는 자동으로 컴파일러가 소멸자 함수 호출
   - ~를 이용해 정의

## 04-상속 및 오버라이딩 등
### 1. 상속
   - 프로그램의 논리적 구조를 계층적으로 구성
   - 예) 자식이 부모 닮은 것
   - 자식클래스가 부모 클래스의 `속성`을 그대로 물려 받아 사용
   - 상속 활용해 `재사용성`을 늘림 
   - 자식클래스의 인스턴스를 만들 때 가장 먼저 부모 클래스의 생성자 호출
   - 이후 자식 클래스의 생성자가 호출
### 2. 다중 상속
   - `여러 개의 클래스`로 부터 `멤버`를 상속 받는 것
   - 한계
     - 여러개의 부모 클래스에 `동일한 멤버` 존재
     - 하나의 클래스를 의도치 않게 `여러번 상속` 받을 가능성 있음
### 3. 오버라이딩
   - 부모 클래스에서 정의된 함수를 `무시`
   - 자식 클래스에서 `동일한 이름`의 함수를 재정의하는 문법
   - 오버라이딩을 적용한 함수의 원형은 기존 함수와 동일한 매개변수를 전달 받음
### 4. 오버로딩
1. 특징
   - 동일한 이름의 함수를 약간 변형해 사용
   - 자주 이루어진 특정한 계산을 연산자 오버로딩을 통해 정리
   - 연산자 또한 원하는 방식으로 수정해 사용
   - 기존에 존재하는 연산자만 정의
   - 멤버 연산자(.), 범위 지정 연산자(::) 등의 몇몇 연산자 오버로딩 처리 못함
   - 기본적인 연산자의 규칙 따라야함
   - 오버로딩이 된 연산자의 피연산자 중 하나는 사용자 정의 자료형 이어야만함.

## 05-캡슐화
### 1. friend
   - 특정한 객체의 모든 멤버에 접근
   - 기존 함수 앞에 `friend` 키워드 붙여 사용
### 2. friend class
   - 두 클래스가 서로 밀접한 연관성 있으며 상대방의 private 멤버에 접근해 할때 클래스 자체를 프렌드로 선언 할 수 있음
   - 모든 멤버함수가 `특정 클래스의 프랜드`
### 3. 정적 멤버(static)
   - 클래스에는 포함되어 있는 멤버로 `모든 객체`가 `공유`하는 멤버
   - 정적 선언된 멤버는 `메모리 상`에 오직 `하나만` 할당 되어 관리
   - public 선언해 외부의 어떠한 클래스에서 접근 가능하며, 오직 하나만 관리
   - 정적멤버는 일반적으로 싱글톤 패턴 등의 다양한 기능을 위해 사용
### 4. 상수 멤버
   - 호출된 객체의 데이터를 변경 할 수없는 멤버
   - 중요한 상수를 정의해서 사용

## 06-다형성
### 1. 특징
   - 여러개의 서로 다른 객체가 `동일한` 기능을 `서로 다른` 방법 사용
   - 예: 무기: 칼, 대포, 총 등 효과음 다르다.
### 2. 자식 클래스에서 오버라이딩 문제점
   - 자식 클래스에서 멤버 함수를 재정의해 사용 하는것은 일반적으로 정상적 동작
   - `포인터 변수`로 객체에 접근할 때는 예상치 못한 결과 발생 할수 있음
   - c++ 컴파일러 
      - 포인터 변수가 가리키고 있는 변수의 타입을 기준으로 호출 안함
      - 포인터의 타입을 기준으로 함수 호출
      - A라는 객체를 가리키는 포인터 변수는 A 객체의 멤버 함수만을 호출 
### 3. 가상 함수
   - 자식 클래스에서 재정의 할 수 있는 멤버함수
   - virtual 키워드를 이용해 가상함수 선언
   - 자식 클래스에서 가상 함수를 재정의하면 재정의된 멤버 함수 또한 가상함수로 분류
### 4. 동적 바인딩
   - 가상 함수는 실행 시간 때 올바른 함수가 실행될 수 있도록 동적 바인딩 사용
   - c++는 특정 함수를 호출 할 때 해당 함수의 루틴이 기록된 메모리 주소를 알아야함
   - 정의된 메모리 공건울 찾기 위해서는 `바인딩` 과정 필요
   - 정적바인딩: 일반적으로 함수의 호출은 컴파일 시기에 고정된 메모리 주소를 이용
### 5. 추상 클래스
   - 하나 이상의 순수 가상 함수를 포함한 클래스
   - 다형성을 효과적으로 프로그램 상에서 구현
   - 자식클래스는 추상 클래스 상속 받은 이후엔 반드시 순수 가상함수를 모두 오버라이딩 해야 해당 개체 사용 가능

## 07-템플릿
### 1. 특징
   - 매개변수의 타입에 따라 함수 및 클래스를 사용
   - 다양한 타입에서 동작 할 수 있는 하나의 객체를 정의
### 2. 함수 템플릿
   - 각각의 자료형에 대해 처음 호출 될때 컴파일러는 해당티입의 인스턴스 생성
   - 이후에 생성된 하나의 인스턴스는 해당 자료형에 대해서 특수화가 이루어짐
### 3. 명시적 특수화
   - 특정한 타입에 대하여 명시적 특수화 기능 제공
### 4. 클래스 템플릿 
   - 자료형 따라서 다르게 동작하는 클래스 집합을 만들 수 있음

## 08-스마트 포인터
### 1. 특징
   - 프로그래머 실수로 `메모리 누수`을 방어하기 위한 수단
   - 포인터처럼 동작하는 `클래스 템플릿`
   - 힙영역에 동적 할당된 메모리 해제는`delete` 키워드 씀
   - new 키워드를 이용해 기본 포인터가 특정한 메모리 주소를 가리키도록 초기화 한 이후에 스마트 포인터에 해당 포인터를 넣어서 사용
### 2. unique_ptr
   - 하나의 스마트 포인터만이 특정한 객체를 처리 할때 사용
   - 특정한 객체의 소유권을 가지고 있을때만 소멸자가 객체를 삭제 할 수 있음
### 3. shared_ptr
   - 하나의 특정한 객체를 참조한 스마트 포인터 개수가 몇개인지 참조
   - 특정한 객체를 새로운 스마트 포인터가 참조할 때마다 참조 횟수 1씩 증가
   - 각 스마트 포인터의 수명이 다할 때마다 1씩 감소
   - 결과적으로 참조 횟수가 0이 되면 delete 키워드를 이용해 메모리에서 데이터를 자동 할당해제
### 4. weak_ptr
   - 하나 이상의 shared_ptr 객체가 참조해 있는 객체에 접근
   - 해당 객체의 소유자의 수에는 포함되지 않는 스마트 포인터
   - 순환 참조 현상을 제거 하기위한 목적 사용

## 09-STL 컨테이너 어댑터
### 1. 특징
   - 활용도 높은 자료구조를 제공
   - 스택, 큐, 우선순위 큐
### 2. 스택
   - 추가: push(원소)
   - 삭제: pop()
   - 조회: top()
   - 검사: empyty() / size()
### 3. 큐
   - 추가: push(원소)
   - 삭제: pop()
   - 조회: front() / back()
   - 검사: empty() /size()
### 4. 덱
   - 양 끝에서 데이터를 넣거나 뺄 수 있는 자료구조
      종류 | 설명
      :--- | --- 
      PUSH_FRONT | 덱의 `앞`에 데이터 `삽입`
      POP_FRONT | 덱의 `앞`에서 데이터 `꺼냄`
      PUSH_BACK | 덱의 `뒤`에 데이터 `삽입`
      POP_BACK | 덱의 `뒤`에서 데이터 `꺼냄`
      INSERT | 덱의 `특정 위치`에 데이터 `삽입`
### 5. 벡터
   - 뒤 쪽에서만 데이터를 넣거나 뺄 수 있는 자료구조
   - 배열처럼 사용하기에 적합
   - 앞뒤로 원소 추가되는 경우 적음
   - `임의 원소`에 접근해야 하는 경우 `덱` 보다 성능 효율적
      종류 | 설명
      :--- | --- 
      PUSH_BACK | 벡터의 `뒤`에 데이터 `삽입`
      POP_BACK | 벡터의 `뒤`에서 데이터 `꺼냄`
      INSERT | 벡터의 `특정 위치`에 데이터 `삽입`

## 10-예외 처리
### 1. 특징
   - 예외란 프로그램이 동작하는 과정에서 발생한 예상치 못한 오류
   - 오류가 발생할 가능성이 높은 곳에 예외처리를 함
### 2. 구문
   - Try: 특정한 코드 블록에서 예외 발생할 수 있음을 명시
   - Catch: 발생한 예외에 대해 핸들러가 특정한 내용 처리
   - Throw: Try 구문에서 발생한 오류 전달