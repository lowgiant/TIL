# OS basic

## 01-운영체제(Operating System) 역할
### 1) 시스템 자원(System Resource)관리자
- 시스템 자원은 `컴퓨터 하드웨어`
  - CPU, Memory
  - I/0 Devices(입출력장치)
    - Monitor, Mouse, Keyboard, Network
  - 저장매체: SSD, HDD(Hard Disk)
### 2) 필요한 이유
> 컴퓨터 하드웨어는 스스로 할 수 있는 것은 없음
- CPU: 각 프로그램이 얼마나 CPU를 사용할지를 결정 못함
- Memory: 각 프로그램이 어느 주소에 저장되어야하는지, 어느정도 메모리에 확보해줘야 하는지 결정 못함
- 저장매체: 어떻게, 어디에 저장할지 결정 못함
- 입력장치: 스스로 무엇을 표시 못함
### 3) 대표적인 운영체제
- Window 
- Mac
- UNIX and LINUX
### 4) 역할
1. 응용프로그램 제어
2. 쉘 및 UI interface: GUI, Batch, Command Line
3. 시스템 콜(System Call)
4. 시스템 자원
   - 프로세스 관리(Process Management)
   - 주기억장치 관리(Main Memory Management)
   - 파일 관리(File Management)
   - 디스크 관리(Disk Management)
   - 입출력 관리(I/O Management)
   - 네트워킹 및 보호/보안(Networking, Protection)

## 02-응용 프로그램
### 1) 특징
- 소프트웨어는 운영체제, 엑셀 등 `다양한 프로그램`을 말함
### 2) 운영체제와 응용프로그램의 관계
- 운영체제의 응용 프로그램을 `관리`
  - 실행
  - 권환 관리
  - 관리자 권한으로 실행 
  - 사용자 관리(로그인)
### 3) 관리하는 이유
- 누구나 만들 수 있음(문제점)
  - 무한 반복문 등 잘 못 작성해 프로그램 다운
  - 모든 파일 삭제막기(권한/사용자 관리)
  - 한 프로그램이 CPU를 독점

## 03-운영체제 역사(Operating System History)
### 1) 1950년
1. ENIAC
    - 응용 프로그램이 `시스템 자원`을 제어
    - 첫 번째 컴퓨터
    - 운영체제가 없음
    - 1개의 프로그램 실행 바쁨
### 2) 1960년 초기
1. 배치 처리 시스템(Batch Processing System)
    - 여러 응용 프로그램을 등록시켜 순차적으로 실행한 시스템
    - 단점
      - 컴퓨터 응답시간(response time)이 오래 걸림
      - 실행 시간 오래 걸림(CPU 점유 문제 때문)
### 3) 1960년 후반
- 운영체제로 구현 되지 않음
- 시간을 잘 쪼개서, 여러 응용 프로그램 실행
  1. 시분할 시스템(Time Shareing System)
     - `다중 사용자` 지원
     - 컴퓨터 응답 시간 최소화한 시스템
  2. 멀티 태스킹(Multi Tasking)
     - 단일 CPU에서 `여러 응용프로그램`의 `병렬` 실행 가능
  3. 멀티프로그래밍
     - 최대한 CPU를 많이 활용한 시스템(시간대비 CPU 활용 높임)  
### 4) 1970년대 이전
- 어셈블러(Assembly)언어로 소프트웨어 개발
  - CPU(명령어), Memory(주소)
  - 컴퓨터마다 각각 커스텀 해줘야함
  - 프로그래밍 복잡도 높음
### 5) 1970년대
- 제대로된 운영체제 나옴!
- 컴파일러: 다시 작성할 필요 없음
- 프로그래밍 복잡도 낮음

  1. UNIX(유닉스) OS
  - 현대 운영체제의 기본기술을 모두 포함한 최초의 운영체제
  - 멀티태스킹, 시분할 시스템, 멀티 프로그래밍
    - 다중 사용자 지원
  - 미국 AT&T 사의 벨 연구소
    - 켄톰슨, 데니스리치: C언어 개바
### 6) 1980년대 
- 개인용 컴퓨터 시대
  - CLI: 터미널 환경(키보드, 검은화면)
  - GUI: GUI환경(마우스)
### 7) 1990년대
1. 응용프로그램 시대
   - 엑셀, 워드 프로세스
   - Window OS 대중화
2. 월드와이드 웹 인터넷 대중화
3. 오픈소스 운동 활성화
   - UNIX계열 OS + 응용프로그램 자체 개발, 소스오픈
   - LINUX 운영체제, 소스 오픈, 무료
### 8) 2000년대 이후
1. 오픈소스 활성화
   - 리눅스 운영체제
   - 아파치
   - MYSQL
   - 안드로이드 등
2. 병렬 처리
   - 가상머신
   - 대용량 처리 등 활성화

## 04-운영체제 구조
### 1) 시스템 콜
- 운영체제 기능을 호출하는 함수
- 운영체제가 제공 해줌
- API 내부에는 시스템 콜을 호출하는 형태로 만들어짐
- 커널 모드로 실행

### 2) 모드
1. 사용자 모드(User mode by applications)
  - 응용 프로그램이 사용(Level 3)
2. 커널 모드(kernel mode by OS)
  - OS가 사용(Level 0~2ß)s

## 05-스케쥴링
### 1) 배치 처리 시스템
- 일괄처리, 배치 처리, batch processing 이라고 부름
- 컴퓨터 프로그램 실행 요청 순서에 따라 순차적 프로그램 실행
- 한번에 등록된 여러 프로그램을 순차적 실행
### 2) 시분한 시스템
-`다중 사용자 지원`을 위해 컴퓨터 응답 시간을 최소화하는 시스템
### 3) 멀티태스킹
-`단일 CPU`에서 여러 응용프로그램이 동시에 실행 되는 것 처럼 `보이도록 하는 시스템`
- 10~20ms 단위로도 실행 응용프로그램이 바뀌는 구조
- 사용자에게는 동시에 실행되는 것처럼 보임
### 4) 멀티 프로세싱
- `여러 CPU`에 하나의 프로그램을 병렬로 실행하는 시스템
### 5) 멀티 프로그래밍
- `최대한 CPU`를 많이 활용하도록 하는 시스템
- 시간 대비 CPU 활용도 높일 수 있음
- 응용 프로그램을 짧은 시간 안에 실행 완료를 시킬 수 있음

## 06-스케쥴링 알고리즘
### 1) FIFO 스케쥴러
- CPU를 처음부터 끝까지 사용
- 가장 간단한 스케쥴러(배치 처리 시스템)
- FCFS(First Come First Served) 스케쥴러
### 2) SJF 스케쥴러
- Shortest Job First 스케쥴러
- 가장 프로세스 실행시간이 `짧은 프로세스`부터 실행 시키는 알고리즘
### 3) 우선순위 기반 스케쥴러
- Priority Based 스케쥴러
  - 정적 우선순위
    - 프로세스마다 우선순위를 미리 지정
  - 동적 우선순위
    - 스케쥴러가 상황에 따라 우선순위를 동적 변경
### 4) Round Robin 스케쥴러
- 시분할 시스템 기반
### 5) 기타
- 선점형 스케쥴러(Preemptive Scheduling)
  - 하나의 프로세스가 다른 프로세스 대신에 프로세스를 차지함
- 비선점형 스케쥴러(Non-preemptive Scheduling)
  - 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음