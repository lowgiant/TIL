# OS basic

## 01-운영체제(Operating System) 역할
### 1) 시스템 자원(System Resource)관리자
- 시스템 자원은 `컴퓨터 하드웨어`
  - CPU, Memory
  - I/0 Devices(입출력장치)
    - Monitor, Mouse, Keyboard, Network
  - 저장매체: SSD, HDD(Hard Disk)
### 2) 필요한 이유
> 컴퓨터 하드웨어는 스스로 할 수 있는 것은 없음
- CPU: 각 프로그램이 얼마나 CPU를 사용할지를 결정 못함
- Memory: 각 프로그램이 어느 주소에 저장되어야하는지, 어느정도 메모리에 확보해줘야 하는지 결정 못함
- 저장매체: 어떻게, 어디에 저장할지 결정 못함
- 입력장치: 스스로 무엇을 표시 못함
### 3) 대표적인 운영체제
- Window 
- Mac
- UNIX and LINUX
### 4) 역할
1. 응용프로그램 제어
2. 쉘 및 UI interface: GUI, Batch, Command Line
3. 시스템 콜(System Call)
4. 시스템 자원
   - 프로세스 관리(Process Management)
   - 주기억장치 관리(Main Memory Management)
   - 파일 관리(File Management)
   - 디스크 관리(Disk Management)
   - 입출력 관리(I/O Management)
   - 네트워킹 및 보호/보안(Networking, Protection)

## 02-응용 프로그램
### 1) 특징
- 소프트웨어는 운영체제, 엑셀 등 `다양한 프로그램`을 말함
### 2) 운영체제와 응용프로그램의 관계
- 운영체제의 응용 프로그램을 `관리`
  - 실행
  - 권환 관리
  - 관리자 권한으로 실행 
  - 사용자 관리(로그인)
### 3) 관리하는 이유
- 누구나 만들 수 있음(문제점)
  - 무한 반복문 등 잘 못 작성해 프로그램 다운
  - 모든 파일 삭제막기(권한/사용자 관리)
  - 한 프로그램이 CPU를 독점

## 03-운영체제 역사(Operating System History)
### 1) 1950년
1. ENIAC
    - 응용 프로그램이 `시스템 자원`을 제어
    - 첫 번째 컴퓨터
    - 운영체제가 없음
    - 1개의 프로그램 실행 바쁨
### 2) 1960년 초기
1. 배치 처리 시스템(Batch Processing System)
    - 여러 응용 프로그램을 등록시켜 순차적으로 실행한 시스템
    - 단점
      - 컴퓨터 응답시간(response time)이 오래 걸림
      - 실행 시간 오래 걸림(CPU 점유 문제 때문)
### 3) 1960년 후반
- 운영체제로 구현 되지 않음
- 시간을 잘 쪼개서, 여러 응용 프로그램 실행
  1. 시분할 시스템(Time Shareing System)
     - `다중 사용자` 지원
     - 컴퓨터 응답 시간 최소화한 시스템
  2. 멀티 태스킹(Multi Tasking)
     - 단일 CPU에서 `여러 응용프로그램`의 `병렬` 실행 가능
  3. 멀티프로그래밍
     - 최대한 CPU를 많이 활용한 시스템(시간대비 CPU 활용 높임)  
### 4) 1970년대 이전
- 어셈블러(Assembly)언어로 소프트웨어 개발
  - CPU(명령어), Memory(주소)
  - 컴퓨터마다 각각 커스텀 해줘야함
  - 프로그래밍 복잡도 높음
### 5) 1970년대
- 제대로된 운영체제 나옴!
- 컴파일러: 다시 작성할 필요 없음
- 프로그래밍 복잡도 낮음

  1. UNIX(유닉스) OS
  - 현대 운영체제의 기본기술을 모두 포함한 최초의 운영체제
  - 멀티태스킹, 시분할 시스템, 멀티 프로그래밍
    - 다중 사용자 지원
  - 미국 AT&T 사의 벨 연구소
    - 켄톰슨, 데니스리치: C언어 개바
### 6) 1980년대 
- 개인용 컴퓨터 시대
  - CLI: 터미널 환경(키보드, 검은화면)
  - GUI: GUI환경(마우스)
### 7) 1990년대
1. 응용프로그램 시대
   - 엑셀, 워드 프로세스
   - Window OS 대중화
2. 월드와이드 웹 인터넷 대중화
3. 오픈소스 운동 활성화
   - UNIX계열 OS + 응용프로그램 자체 개발, 소스오픈
   - LINUX 운영체제, 소스 오픈, 무료
### 8) 2000년대 이후
1. 오픈소스 활성화
   - 리눅스 운영체제
   - 아파치
   - MYSQL
   - 안드로이드 등
2. 병렬 처리
   - 가상머신
   - 대용량 처리 등 활성화

## 04-운영체제 구조
### 1) 시스템 콜
- 운영체제 기능을 호출하는 함수
- 운영체제가 제공 해줌
- API 내부에는 시스템 콜을 호출하는 형태로 만들어짐
- 커널 모드로 실행

### 2) 모드
1. 사용자 모드(User mode by applications)
  - 응용 프로그램이 사용(Level 3)
2. 커널 모드(kernel mode by OS)
  - OS가 사용(Level 0~2ß)s

## 05-스케쥴링
### 1) 배치 처리 시스템
- 일괄처리, 배치 처리, batch processing 이라고 부름
- 컴퓨터 프로그램 실행 요청 순서에 따라 순차적 프로그램 실행
- 한번에 등록된 여러 프로그램을 순차적 실행
### 2) 시분한 시스템
-`다중 사용자 지원`을 위해 컴퓨터 응답 시간을 최소화하는 시스템
### 3) 멀티태스킹
-`단일 CPU`에서 여러 응용프로그램이 동시에 실행 되는 것 처럼 `보이도록 하는 시스템`
- 10~20ms 단위로도 실행 응용프로그램이 바뀌는 구조
- 사용자에게는 동시에 실행되는 것처럼 보임
### 4) 멀티 프로세싱
- `여러 CPU`에 하나의 프로그램을 병렬로 실행하는 시스템
### 5) 멀티 프로그래밍
- `최대한 CPU`를 많이 활용하도록 하는 시스템
- 시간 대비 CPU 활용도 높일 수 있음
- 응용 프로그램을 짧은 시간 안에 실행 완료를 시킬 수 있음

## 06-스케쥴링 알고리즘
### 1) FIFO 스케쥴러
- CPU를 처음부터 끝까지 사용
- 가장 간단한 스케쥴러(배치 처리 시스템)
- FCFS(First Come First Served) 스케쥴러
### 2) SJF 스케쥴러
- Shortest Job First 스케쥴러
- 가장 프로세스 실행시간이 `짧은 프로세스`부터 실행 시키는 알고리즘
### 3) 우선순위 기반 스케쥴러
- Priority Based 스케쥴러
  - 정적 우선순위
    - 프로세스마다 우선순위를 미리 지정
  - 동적 우선순위
    - 스케쥴러가 상황에 따라 우선순위를 동적 변경
### 4) Round Robin 스케쥴러
- 시분할 시스템 기반
### 5) 기타
- 선점형 스케쥴러(Preemptive Scheduling)
  - 하나의 프로세스가 다른 프로세스 대신에 프로세스를 차지함
- 비선점형 스케쥴러(Non-preemptive Scheduling)
  - 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음

## 07-인터럽트
### 1) 특징
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치 및 예외 상황이 발생해 처리가 필요한 경우에 CPU에 알려서 처리하는 기술
### 2) 필요 이유
1. 선점형 스케쥴러 구현
   - 프로세스 running중에 스케쥴러가 이를 중단시킴
   - 다른 프로세스로 `교체`하기 위해 현 프로세스 실행 중단
   - 스케쥴러 코드가 실행이 돼 현 프로세스 실행 중지 시킴
2. IO Deviced와의 커뮤니케이션
   - 저장매체에서 데이터 처리완료시, 프로세스를 깨워야함
3. 예외 상황 핸들링
   - CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우, CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 함
### 3) 종류
1. 내부 인터럽트
   - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
     - 0으로 나눴을 때
     - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
     - 계산 결과가 Overflow/Underflow 날때
2. 외부 인터럽트
   - 주로 하드웨어에서 발생되는 이벤트(프로그램 외부)
     - 전원 이상
     - 기계문제
     - 키보드 등 IO 관련 이벤트
     - Timer 이벤트
3. 시스템 콜 인터럽트
  - 시스템콜 실행을 위해 강제로 코드에 인터럽트 명령 넣어 CPU 실행 시켜야함
  - 시스템 콜 실제 코드
    - eax 레지스터에 시스템 콜 번호를 넣고,
    - ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,
    - 소프트웨어 인터럽트 명령을 호출하면서 Ox80값을 넘겨줌
### 4) 처리 방식
- CPU가 프로그램을 실행 하고 있을 때
1. 입출력 하드웨어 등의 장치 이슈 발생
   - 파일 처리가 끝났다는 것을 운영체제에 알려주기
   - 운영체제는 해당 프로세스를 block state에서 실행 대기(ready) 상태로 프로세스 상태 변경하기
2. 예외 상황이 발생
   - 0으로 나누는 계산이 발생해 예외 발생을 운영체제에 알려줌
   - 운영체제가 해당 프로세스 실행 중지/ 에러 표시