# OS basic

## 01-운영체제(Operating System) 역할
### 1) 시스템 자원(System Resource)관리자
- 시스템 자원은 `컴퓨터 하드웨어`
  - CPU, Memory
  - I/0 Devices(입출력장치)
    - Monitor, Mouse, Keyboard, Network
  - 저장매체: SSD, HDD(Hard Disk)
### 2) 필요한 이유
> 컴퓨터 하드웨어는 스스로 할 수 있는 것은 없음
- CPU: 각 프로그램이 얼마나 CPU를 사용할지를 결정 못함
- Memory: 각 프로그램이 어느 주소에 저장되어야하는지, 어느정도 메모리에 확보해줘야 하는지 결정 못함
- 저장매체: 어떻게, 어디에 저장할지 결정 못함
- 입력장치: 스스로 무엇을 표시 못함
### 3) 대표적인 운영체제
- Window 
- Mac
- UNIX and LINUX
### 4) 역할
1. 응용프로그램 제어
2. 쉘 및 UI interface: GUI, Batch, Command Line
3. 시스템 콜(System Call)
4. 시스템 자원
   - 프로세스 관리(Process Management)
   - 주기억장치 관리(Main Memory Management)
   - 파일 관리(File Management)
   - 디스크 관리(Disk Management)
   - 입출력 관리(I/O Management)
   - 네트워킹 및 보호/보안(Networking, Protection)

## 02-응용 프로그램
### 1) 특징
- 소프트웨어는 운영체제, 엑셀 등 `다양한 프로그램`을 말함
### 2) 운영체제와 응용프로그램의 관계
- 운영체제의 응용 프로그램을 `관리`
  - 실행
  - 권환 관리
  - 관리자 권한으로 실행 
  - 사용자 관리(로그인)
### 3) 관리하는 이유
- 누구나 만들 수 있음(문제점)
  - 무한 반복문 등 잘 못 작성해 프로그램 다운
  - 모든 파일 삭제막기(권한/사용자 관리)
  - 한 프로그램이 CPU를 독점

## 03-운영체제 역사(Operating System History)
### 1) 1950년
1. ENIAC
    - 응용 프로그램이 `시스템 자원`을 제어
    - 첫 번째 컴퓨터
    - 운영체제가 없음
    - 1개의 프로그램 실행 바쁨
### 2) 1960년 초기
1. 배치 처리 시스템(Batch Processing System)
    - 여러 응용 프로그램을 등록시켜 순차적으로 실행한 시스템
    - 단점
      - 컴퓨터 응답시간(response time)이 오래 걸림
      - 실행 시간 오래 걸림(CPU 점유 문제 때문)
### 3) 1960년 후반
- 운영체제로 구현 되지 않음
- 시간을 잘 쪼개서, 여러 응용 프로그램 실행
  1. 시분할 시스템(Time Shareing System)
     - `다중 사용자` 지원
     - 컴퓨터 응답 시간 최소화한 시스템
  2. 멀티 태스킹(Multi Tasking)
     - 단일 CPU에서 `여러 응용프로그램`의 `병렬` 실행 가능
  3. 멀티프로그래밍
     - 최대한 CPU를 많이 활용한 시스템(시간대비 CPU 활용 높임)  
### 4) 1970년대 이전
- 어셈블러(Assembly)언어로 소프트웨어 개발
  - CPU(명령어), Memory(주소)
  - 컴퓨터마다 각각 커스텀 해줘야함
  - 프로그래밍 복잡도 높음
### 5) 1970년대
- 제대로된 운영체제 나옴!
- 컴파일러: 다시 작성할 필요 없음
- 프로그래밍 복잡도 낮음

  1. UNIX(유닉스) OS
  - 현대 운영체제의 기본기술을 모두 포함한 최초의 운영체제
  - 멀티태스킹, 시분할 시스템, 멀티 프로그래밍
    - 다중 사용자 지원
  - 미국 AT&T 사의 벨 연구소
    - 켄톰슨, 데니스리치: C언어 개바
### 6) 1980년대 
- 개인용 컴퓨터 시대
  - CLI: 터미널 환경(키보드, 검은화면)
  - GUI: GUI환경(마우스)
### 7) 1990년대
1. 응용프로그램 시대
   - 엑셀, 워드 프로세스
   - Window OS 대중화
2. 월드와이드 웹 인터넷 대중화
3. 오픈소스 운동 활성화
   - UNIX계열 OS + 응용프로그램 자체 개발, 소스오픈
   - LINUX 운영체제, 소스 오픈, 무료
### 8) 2000년대 이후
1. 오픈소스 활성화
   - 리눅스 운영체제
   - 아파치
   - MYSQL
   - 안드로이드 등
2. 병렬 처리
   - 가상머신
   - 대용량 처리 등 활성화

## 04-운영체제 구조
### 1) 시스템 콜
- 운영체제 기능을 호출하는 함수
- 운영체제가 제공 해줌
- API 내부에는 시스템 콜을 호출하는 형태로 만들어짐
- 커널 모드로 실행

### 2) 모드
1. 사용자 모드(User mode by applications)
  - 응용 프로그램이 사용(Level 3)
2. 커널 모드(kernel mode by OS)
  - OS가 사용(Level 0~2ß)s

## 05-스케쥴링
### 1) 배치 처리 시스템
- 일괄처리, 배치 처리, batch processing 이라고 부름
- 컴퓨터 프로그램 실행 요청 순서에 따라 순차적 프로그램 실행
- 한번에 등록된 여러 프로그램을 순차적 실행
### 2) 시분한 시스템
-`다중 사용자 지원`을 위해 컴퓨터 응답 시간을 최소화하는 시스템
### 3) 멀티태스킹
-`단일 CPU`에서 여러 응용프로그램이 동시에 실행 되는 것 처럼 `보이도록 하는 시스템`
- 10~20ms 단위로도 실행 응용프로그램이 바뀌는 구조
- 사용자에게는 동시에 실행되는 것처럼 보임
### 4) 멀티 프로세싱
- `여러 CPU`에 하나의 프로그램을 병렬로 실행하는 시스템
### 5) 멀티 프로그래밍
- `최대한 CPU`를 많이 활용하도록 하는 시스템
- 시간 대비 CPU 활용도 높일 수 있음
- 응용 프로그램을 짧은 시간 안에 실행 완료를 시킬 수 있음

## 06-스케쥴링 알고리즘
### 1) FIFO 스케쥴러
- CPU를 처음부터 끝까지 사용
- 가장 간단한 스케쥴러(배치 처리 시스템)
- FCFS(First Come First Served) 스케쥴러
### 2) SJF 스케쥴러
- Shortest Job First 스케쥴러
- 가장 프로세스 실행시간이 `짧은 프로세스`부터 실행 시키는 알고리즘
### 3) 우선순위 기반 스케쥴러
- Priority Based 스케쥴러
  - 정적 우선순위
    - 프로세스마다 우선순위를 미리 지정
  - 동적 우선순위
    - 스케쥴러가 상황에 따라 우선순위를 동적 변경
### 4) Round Robin 스케쥴러
- 시분할 시스템 기반
### 5) 기타
- 선점형 스케쥴러(Preemptive Scheduling)
  - 하나의 프로세스가 다른 프로세스 대신에 프로세스를 차지함
- 비선점형 스케쥴러(Non-preemptive Scheduling)
  - 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음

## 07-인터럽트
### 1) 특징
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치 및 예외 상황이 발생해 처리가 필요한 경우에 CPU에 알려서 처리하는 기술
### 2) 필요 이유
1. 선점형 스케쥴러 구현
   - 프로세스 running중에 스케쥴러가 이를 중단시킴
   - 다른 프로세스로 `교체`하기 위해 현 프로세스 실행 중단
   - 스케쥴러 코드가 실행이 돼 현 프로세스 실행 중지 시킴
2. IO Deviced와의 커뮤니케이션
   - 저장매체에서 데이터 처리완료시, 프로세스를 깨워야함
3. 예외 상황 핸들링
   - CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우, CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 함
### 3) 종류
1. 내부 인터럽트
   - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
     - 0으로 나눴을 때
     - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
     - 계산 결과가 Overflow/Underflow 날때
2. 외부 인터럽트
   - 주로 하드웨어에서 발생되는 이벤트(프로그램 외부)
     - 전원 이상
     - 기계문제
     - 키보드 등 IO 관련 이벤트
     - Timer 이벤트
3. 시스템 콜 인터럽트
  - 시스템콜 실행을 위해 강제로 코드에 인터럽트 명령 넣어 CPU 실행 시켜야함
  - 시스템 콜 실제 코드
    - eax 레지스터에 시스템 콜 번호를 넣고,
    - ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,
    - 소프트웨어 인터럽트 명령을 호출하면서 Ox80값을 넘겨줌
### 4) 처리 방식
- CPU가 프로그램을 실행 하고 있을 때
1. 입출력 하드웨어 등의 장치 이슈 발생
   - 파일 처리가 끝났다는 것을 운영체제에 알려주기
   - 운영체제는 해당 프로세스를 block state에서 실행 대기(ready) 상태로 프로세스 상태 변경하기
2. 예외 상황이 발생
   - 0으로 나누는 계산이 발생해 예외 발생을 운영체제에 알려줌
   - 운영체제가 해당 프로세스 실행 중지/ 에러 표시

## 08-프로세스 구조
### 1) 프로세스
1. stack 
  - 임시 데이터(함수 호출, 로컬 변수등)
2. heap
  - 코드에서 동적으로 만들어진 데이터
3. data
  - 변수/초기화된 데이터
4. text(Code)
  - 코드
### 2) Process Control Block(PCB)
- 프로세스가 실행 중인 상태를 캡쳐 및 구조화해 저장
1. Process ID
2. Register 값
  1. PC(Program Counter)
  2. SP(Stack Pointer)
3. Scheduiling Info(Process State)
4. Memory Info(메모리 사이즈 limit)

## 09-문맥교환(Context Switching)
### 1) 특징
- CPU에 실행할 프로세스를 교체하는 기술
  1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서 메인 메모리에 저장
  2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보(PC, SP)를 CPU에 넣고, 실행
### 2) Cost
- Cache 초기화
- Memory Mapping 초기화
- Kernel은 항상 실행되어야 함.(메모리 접근 위해)
- 프로세스가 쓰레드 보다 비용이 많이 듬
  - 쓰레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문
  - 문맥교환이 발생시 Stack 영역만 변경을 진행하면 됨.

## 10-InterProcess Communication
### 1) 커뮤니케이션
- 커널 공간 활용(공유)
- 프로세스는 다른 프로세스의 `공간`을 접근할 수 없다.
- 다른 프로세스와 커뮤니케이션을 할 수 있도록 IPC를 제공함.
### 2) 통신에 필요한 이유
- 여러 프로세스를 만들어 동시 실행해 성능을 높임
- 이 때 프로세스간의 상태확인과 데이터 송수신이 필요함.
### 3) 방법
1. File 사용
2. Message Queue
3. Shared Memory
4. Pipe
5. Signal
6. Semaphore
7. Socket

## 11-스레드
### 1) 특징
- Light Weight Process라고도함.
- 하나의 프로세스에 여러개의 스레드 생성강
- 스레드들은 동시에 실행가능
- 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
- 멀티 스레드
  - 소프트웨어 병행 작업처리를 위해 멀티 스레드를 사용함
### 2) 장점
1. 사용자에 대한 응답성 향상
2. 자원 공유 효율
  - IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요없음
  - 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
3. 작업이 분리돼 코드가 간결
### 3) 단점
1. 스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받음
2. 스레드 많이 생성하면, Context Switching이 많이 일어나 성능 저하
  - 리눅스 OS는 Thread를 Process와 같이 다룸
### 4) 프로세스 vs 스레드
프로세스 | 스레드
--- | ---
독립적 | 프로세스의 서프셋
각각 자원가짐 | 프로세스의 자원 공유
자신만의 주소영역 가짐 | 주소영역 공유
IPC 기법으로 통신 | 필요 없음

## 12-동기화
### 1) 특징
- 작업들 사이에 실행 시기를 맞추는 것
- 여러 스레드가 동일한 자원 접근시 동기화 이슈 발생
  - 동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향을 줌
### 2) 이슈 해결 방안
- 상호배제
- 쓰레드는 프로세스 모든 데이터를 접근할 수 있음
  - 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요
  - 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막아라
### 3) Mutex와 세마포어
- Critical Section(임계구역)에 대한 접근을 막기 위해 Locking 메커니즘이 필요
1. Mutex(binary semapohore)
  - 임계구역에 하나의 스레드만 들어갈 수 있음
2. Semaphore
  - 임계구역에 여러 스레드가 들어갈 수 있음
  - counter를 두어서 동시에 리소스에 접근 할수 있는 허용가능한 스레드 수를 제어
  - P: 검사(임계영역에 들어갈 때)
    - s 값이 1이상이면, 임계 영역 진입 후, s값 1차감(s값이 0이면 대기)
  - V: 증가(임계영역에서 나올때)
    - s 값을 1더하고, 임계 영역을 나옴
  - S: 세마포어 값(초기 값 만큼 여러 프로세스가 동시 임계 영역 접근 가능)
  - 바쁜대기: wait()은 S가 0이라면, 임계영역에 들어가기 위해, 반복문 수행
  - 대기큐: S가 음수일 경우, 바쁜 대기 대신, 대기큐 넣음
  - 재실행: wakeup() 함수를 통해 대기큐에 있는 프로세스 재실행
  - 주요 함수
    - sem_open(): 세마포어를 생성
    - sem_wait(): 임계영역 접근 전, 세마포어를 잠그고, 세마포어가 잠겨 있다면, 풀릴 때까지 대기
    - sem_post(): 공유자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제한다.

## 13-가상메모리
### 1) 특징
- 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
- 메모리가 실제 메모리보다 많아 보이게 하는 기술
  - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  - 프로세스간 공간 분리로 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
### 2) 필요한 이유
- 하나의 프로세스만 실행 가능한 시스템
  1. 프로그램을 메모리로 로드
  2. 프로세스 실행
  3. 프로세스 종료(메모리 해제)
- 여러 프로세스 동시 실행 시스템
  1. 메모리 용량 부족 이슈
  2. 프로세스 메모리 영역간에 침범이슈
### 3) 구조
- 프로세스는 가상 주소를 사용하고 실제 해당 주소에서 데이터를 읽고 / 쓸대만 물리주소로 바꿔주면 됨.
  - 가상주소: 프로세스가 참조하는 주소
  - 물리주쇠: 실제 메모리 주소
- MMU
  - CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할때, 해당 주소를 물리 주소 값으로 변환해 주는 하드웨어 장치

## 14-페이징 시스템
### 1) 특징
- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭한 물리 주소 공간을 관리
- 하드웨어 지원이 필요
  - intel x86 시스템에서는 4kb, 2MB, 1GB지원
- 리눅스에서는 4KB로 paging
- 페이지 번호를 기반으로 가상 주소 / 물리 주소 매핑 정보를 기록 / 사용
### 2) 페이지 테이블
- 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
- 가상주소 v =(p,d)라면
  - p: 페이지 번호
  - d: 페이지 처음부터 얼마 떨어진 위치인지 
### 3) paging sysytem 동작
- 해당 프로세스에서 특정 가상 주소 엑세스를하려면
  - 해당 프로세스의 page table에 해당 가상 주소가 포함된 page번호가 있는지 확인
  - page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아냄
### 4) MMU
- CPU는 가상 주소 접근시 
  - MMU 하드웨어 장치를 통해 물리 메모리 접근
- 프로세스 생성시, 페이지 테이블 정보 생성
  - PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리메모리에 적재
  - 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  - CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서, 물리 주소를 가져옴
### 5) 다중 단계 페이징 시스템
- 32bit 시스템에서 4KB페이지를 위한 페이징 시스템
  - 하위 12bit는 오프세
  - 상위 20bit가 페이징 번호이므로, 2의 20승개의 페이지 정보가 필요함
- 페이징 정보를 단계를 나누어 생성
  - 필요없는 페이지는 생성하지 않으면, 공간 절약가능
### 6) 페이징 시스템과 공유메모리
- 프로세스간 동일한 물리 주소를 가리킬 수 있음(공간 절약, 메모리 할당 시간 절약)
- 물리 주소 데이터 변경시
  - 물리 주소에 데이터 수정 시도시 물리주소를 복사할 수 있음(copy-on-write)
### 7) 요구 페이징
- 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
  - 선행페이징의 반대 개념: 미리 프로세스 관련 모든 데이터를 메모리에 올려 놓고 실행하는 개념
  - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)
### 8) 페이지 폴트
- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림


## 15-페이징 교체 
### 1) 특징
- 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차 있을 때 주로 발생
### 2) 교체 알고리즘
1. FIFO
  - 가장 먼저 들어온 페이지를 내림
2. OPT
  - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내림
  - 일반 OS에서 구현 불가
3. LPU
  - 가장 오래전에 사용된 페이지 교체
  - OPT 교체 알고리즘이 구현이 불가해 과거 기록을 기반으로 시도
4. LFU
  - 가장 적게 사용된 페이지 내림
5. NUR
  - LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
  - 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠(R,M)
### 3) 스레싱
- 반복적으로 페이지 폴트가 발생해 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황

## 16-세그멘테이션
### 1) 특징
- 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할
- 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할
  - X86 리얼모드 
    - CS(code Segment), DS(Data Segment), SS(Stack Segment),ES(Extra Segment)로 세그먼트를 나누어, 메모리 접근
- 크기가 다른 Segment 단위로 물리 메모리 로딩
- 하드웨어 지원 필요
- 외부 단편화
### 2) 세그먼트 가상죽소
- v = (s,d): s는 세그먼트 번호, d는 블록 내 세그먼트의 변위

## 17-파일시스템
### 1) 특징
- 동일한 시스템콜을 사용해 다양한 파일 시스템 지원 가능토록 구현
  - read/write 시스템 콜 호출시, 각 기기 및 파일 시스템에 따라 실질적인 처리를 담당
    - 예: read_spec/write_spec
  - 파일을 실제 어떻게 저장할지는 다를 수 있음
    - 리눅스의 경우 ext4외 NTFS, FAT32 파일 시스템 지원

    함수 | 의미
    --- | --- 
    open | 존재한 파일 읽기 또는 쓰기용<br>새로운 파일 생성해 연다
    creat | 새로운 파일을 생성해 연다
    close | open 또는 creat로 열려진 파일을 닫음
    read | 열려진 파일로 부터 데이터를 읽어 들임
    write | 열려진 파일에 데이터를 씀
    lseek | 파일 안에서 읽기/쓰기 포인터를 지정한 바이트 위치로 이동  
    unlink / remove | 파일을 삭제함
### 2) inode 방식 파일 시스템
- 파일 시스템 기본 구조
  - 수퍼블록: 파일 시스템 정보
  - 아이노드 블록: 파일 상세 정보
  - 데이터 블록: 실제 데이터
- 파일:inode 고유값과 자료구조에 의해 주요 정보관리
  - '파일이름: inodee'로 파일이름은 inode 번호와 매칭
  - 파일 시스템에서는 inode를 기반으로 파일 엑세스
  - inode 기반 메타 데이터 저장
- inode 기반 메타데이터
  - 파일 권한
  - 소유자 정보
  - 파일 사이즈
  - 생성 시간 
  - 데이터 저장 위치
### 3) 디렉토리 엔트리
- 리눅스 파일 탐색: 예- /home/ubuntu/link.txt
  - 각 디렉토리 엔트리(dentry)를 탐색
    - 각 엔트리는 해당 디렉토리 파일/디렉토리를 가지고 있음
  - '/' dentry에서 'home'을 찾고 
  - 'home'에서 'ubuntu'를 찾고
  - 'ubuntu에서 link.txt 파일이름에 해당 하는 inode를 얻음
### 4) 가상 파일 시스템(Virtual File System)
- Network등 다양한 기기도 동일한 파일 시스템 인터페이스를 통해 관리 기능
  - 예: read/write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현(운영체제 내부)

## 18-부팅
### 1) 특징
- 컴퓨터를 켜서 동작시키는 절차
- Boot 프로그램
  - 운영체제 커널을 Storage에서 특정 주소의 물리 메모리로 복사
  - 커널의 처음 실행위치로 PC를 가져다 놓는 프로그램
### 2) 부팅 과정
1. 컴퓨터 전원 버튼 클릭
2. BIOS가 특정 Storage 읽어와 bootstrap loader를 메모리에 올리고 실행
3. bootstrap loader 프로그램이 있는 곳을 찾아서 실행

## 19-가상 머신
### 1) 특징
- 하나의 하드웨어에 다수의 운영체제를 설치
- 개별 컴퓨터처럼 동작하도록 하는 프로그램
- Bare-Metal 방식이 가장 성능 좋음
  - 하드웨어 직접 엑세스 가능
  - AWS(클라우드 컴퓨팅)환경도 Bare-Metal 기반 가상 머신 기술활용(KVM)
### 2) 종류
1. Hardware에서 직접 구동
  - 운영체제와 응용프로그램을 물리적 하드웨어에서 분리하는 프로세스
  - 하이퍼바이저 또는 버추얼 머신 모니터(VMN)가 Hardware에서 직접 구동
    - Xen, KVM
2. Host OS 상위에 설치
  - VMWare, Parallels Desktop(mac)
### 3) 가상화
1. 전가상화
  - 각 가상머신이 하이퍼바이저를 통해서 하드웨어와 통신
    - 하이퍼바이저가 마치 하드웨어인 것처럼 동작
    - 가상머신의 OS는 자신이 가상 머신인 상태인지를 모름
2. 반가상화
  - 각 머신에서 직접 하드웨어와 통신
  - 각 가상머신에 설치된 OS는 가상 머신인 경우 각 명령에 하이퍼 바이저 명령을 추가해서 하드웨어와 통신
### 4) Docker
- 운영체제 레벨에서 별도로 분리된 실행환경을 제공(커널 추상화)
  - 리눅스 처음 설치했을때와 유사한 실행환경을 만들어 줌
  - 리눅스 컨테이너 기술로 macOs나 window에 설치할 경우는 가상 머신 기반 제공
  - Data Enginerring에서 Docker로 시스템 환경 설정 + 프로그램을 한번에 배포
    - 프로그램 업데이트 -> docker 이미지 작성 -> Jenkins로 배치잡 생성 및 실행

## 20-리눅스
### 1) 특징
- UNIX 계열의 운영체제 
- 주로 서버, 클라우드 컴퓨팅에서 사용
- 프로그래밍에도 유용
### 2) 역사
1. 시작
  - 리누스 토발즈가 개발
    - 대학 UNIX 컴퓨터를 집에서 쓰고 싶어서
    - 다중 사용자, 다중 작업(시분할 시스템, 멀티 태스킹)을 지원하는 유닉스(UNIX)와 유사한 운영체제
2. GNU 프로젝트
   - Gnu is Not Unix
   - 유닉스 운영체제를 여러 회사에서 각자 개발
   - 소스를 공유하지 않는 문화에서 반발
   - 리차드 스톨만
     - 초기 컴퓨터 개발 공동체의 상호협력적인 문화로 돌아갈 것 주장
     - 1985년도에 GNU 선언문 발표
3. GPL 라이선스
   - 어떤 목적, 형태로든 사용할 수 있음
   - 변경된 프로그램을 다시 배포한 경우 동일한 GPL 라이선스로 공개해야함
   - 소스 오픈을 장려함
4. GNU Hurd
   - 운영체제 커널 개발 시도
   - 라이브러리, 컴파일러, 에디터 쉘 개발
   - 개발이 지연되자 리누스 토발즈가 리눅스 커널 소스 오픈
   - GNU 프로젝트 산출물과 리눅스 커널이 통합 개발됨
### 3) 기본 구성
- 모든 것은 파일이라는 철학에 따름
  - 인터렉션은 파일을 읽고, 쓰는 것 처럼 이루어짐
  - 마우스, 키보드와 같은 모든 디바이스 관련된 기술도 파일과 같이 다룸
- 파일 네임스페이스
  - 전역 네임스페이스 사용
    - /media/file.jpg
- 파일은 inode 고유값과 자료구조에 의해 주요 정보 관리
### 4) 프로세스
- 리눅스 실행 파일 포맷(ELF)
  - 코드(텍스트), 콜스택, 데이터 및 BSS 섹션 등
- 다양한 시스템 리소스와 관련
  - 시스템콜 호출을 통해 리소스 처리 가능토록 구성
    - 타이머, 시그널, 파일, 네트워크, 디바이스, IPC기법
- 가상메모리 지원
- 각 프로세스는 pid(프로세스 ID) 고유값으로 구분
- init 프로세스(첫 번째 프로세스)를 기반으로 fork() 시스템콜을 사용해 신규 프로세스가 생성
### 5) 권한
- 운영체제는 사용자/리소스 권한을 관리
- 리눅스는 사용자/그룹으로 권한 관리
- root는 슈퍼관리자
- 파일마다 소유자, 소유자 그룹, 모든 사용자에 대해
  - 읽고, 쓰고, 실행하는 권한을 관리
  - 접근 권한 정보는 inode의 자료구조에 저장

## 21-쉘
### 1) 특징
- 사용자의 명령을 해석해 커널에 명령을 요청해주는 역할
- 관련된 시스템콜 사용해 프로그래밍 작성
### 2) 쉘 종류
1. Bourne-Again Shell(bash)
   - GNU 프로젝트의 일환으로 개발
   - 대부분의 리눅스에 기본 설정
2. Bourne Shell(sh)
3. C Shell(csh)
4. Korn Shell(ksh)
  - 유닉에서 가장 많이씀
### 3) 명령어
1. whoami
   - 로그인한 사용자 ID 출력
2. passwd
   - 로그인한 사용자 ID의 암호 변경
3. useradd
   - 사용자 기본 설정 자동으로 하지 않음
4. adduser
   - 사용자 기본 설정을 자동으로 수행
5. su
  - 사용자 변경
    - 보통 su - 와 함께 사용
      - su root: 현재 사용자의 환경설정 기반, root로 변경
      - su - root: 변경된 사용자의 환경 설정을 기반으로, root로 전환
6. sudo 명령어
  - root 권한으로 실행
    - root 계정으로 로그인 하지 않은 상태에서 root 권한이 필요한 명령을 실행할 수 있도록 하는 프로그램 
    - 기본 사용법
      - sudo 명령어
        - sudo apt-get update

## 22-파일 및 권한 관련 명령어
### 1) 파일 명령어
- pwd: 현재 디렉토리 위치
- cd: 디렉토리 이동
- ls: 파일 목록 출력
### 2) 파일 권한 
- 파일마다 소유자, 그룹, 모든 사용자에 대한 권한이 있음
  - 읽고(r), 쓰고(w), 실행(x)하는 권한 설정
  - 소유자 접근 권한 정보는 inode에 저장
### 3) 파일 권한 변경
1. 기호 문자를 사용한 방법
   - chmod g+rx test.py
2. 숫자를 사용한 방법
   - chmod 777 test.py
### 4) 소유자 변경
- chown [옵션] [소유자:소유그룹][파일]
- chown root:root file
### 5) 파일 확인 및 삭제
1. cat: 파일확인
2. head: 파일 시작 부분 
3. tail: 파일 끝 부분
4. more: 파일 보기(화면이 넘어갈 경우 넘어가기 전까지 보여줌)
5. rm : 파일 및 폴더 삭제
  - rm filename
  - rm -rf foldername

## 23-리다이렉션과 파이프
### 1) 표준 입출력
- commend로 실행된 프로세스는 세가지 스트림을 가지고 있음
  - 표준 입력 스트림 - stdin
  - 표준 출력 스트림 - stdout
  - 오류 출력 스트림 - stderr
- 모든 스트림은 일반적인 plain text로 console에 출력하도록 되어 있음
### 2) 리다이렉션
- 표준 스트림 흐름을 바꿔줌
  - \>, <을 사용함
  - 주로 명령어 표준 출력을 화면이 아닌 파일에 쓸 때 사용
  - 예) is -al > filename.txt
    - 텍스트 파일로 저장
    - \> 하게 더 추가 도면 출력 결과가 추가됨
  - 예 head -3 < filename.txt
    - 텍스트 파일의 처음 3라인 까지 출력  
### 3) 파이프
- 두 프로세스 사이에서 한 프로세스의 출력 스트림을 또다른 프로세스의 입력 스트림으로 사용할 때 사용됨
  - 예) ls -al | grip file
  - ls 출력된 값에서 file이라는 문구를 찾아서 있는지 출력 함

## 24-프로세스 관리 및 제어
### 1) 프로세스 VS 바이너리
- 코드 이미지 또는 바이너리: 실행파일
- 실행 중인 프로그램: 프로세스
  - 가상 메모리 및 물리 메모리 정보
  - 시스템 리소스 관련 정보
  - 스케쥴링 단위
### 2) 프로세스 실행 환경
- 유닉스 철학
  - 여러 프로그램이 서로 유기적으로 각자의 일을 수행하면서 전체 시스템이 동작하도록 하는 모델
- foreground process
  - 쉘에서 해당 프로세스 실행을 명령한 후, 해당 프로세스 수행 종료까지 사용자가 다른 입력을 하지 못하는 프로세스
- background process
  - 쉘에서 해당 프로세스 실행시, 맨 뒤에 & 를 붙여줌
  - 예) find / -name '*.py' > list.txt &
### 3) 프로세스 상태 확인
- ps 
- option(s)
  - -a : 시스템을 사용하는 모든 사용자의 프로세스 출력
  - -u : 프로세스 소유자에 대한 상세 정보 출력
  - -l : 프로세스 관련 상세 정보 출력
  - -x : 터미널에 로그인한 후 실행한 프로세스가 아닌 프로세스들도 출력함
  - -e : 해당 프로세스와 관련된 환경 변수 정보도 함께 출력
  - -f : 프로세스 간 관계 정보도 출력 
- 데몬프로세스(daemon process)
  - daemon은 악마를 의미함
  - 사용자 모르게 시스템 관리를 위해 실행되는 프로세스로 보통 시스템이 부팅될 때 자동실행(예: ftpd, inetd)
- 출력 정보
  - USER : 프로세스를 실행시킨 사용자 ID
  - PID : 프로세스 ID
  - %CPU : 마지막 1분 동안 프로세스가 사용한 CPU시간의 백분률
  - %MEM : 마지막 1분 동안 프로세스가 사용한 메모리 백분율
  - VSZ : 프로세스가 사용하는 가상 메모리 크기
  - RSS : 프로세스에서 사용하는 실제 메모리 크기
  - STAT : 프로세스 상태
  - START : 프로세스가 시작된 시간
  - TIME : 현재까지 사용된 CPU 시간(분:초)
  - COMMAND : 명령어 
- 중지 시키기
  - kill 명령어
    - 사용법 
      1. kill % 작업 번호(job number)
      2. kill 프로세스 ID(pid)
      3. 작업 강제 종료 옵션 -9
        - 예) find / -name '*.py' > list.txt &
        -     kill -9 57
### 4) 자주 쓰는 명령
- ps aux | grep (프로세스명)
  - 프로세스가 실행 중인지 확인
  - 관련 프로세스에 대한 정보 출력 
- kill -9 프로레스 ID(pid)
  - 해당 프로세스를 강제로 죽임
- 명령 & 터미널에서 다른 작업을 해야하거나, 프로세스 실행에 오랜 시간이 걸릴 경우 background로 실행

## 25-파일 시스템
### 1) 가상 파일 시스템
- 파일 네임스페이스
  - A 드라이버(A:/)
  - 전역 네임 스페이스 사용
    - /media/floofy/dave.jpg
    - 예) cat tty
### 2) 슈퍼블록, inode와 파일
- 슈퍼블록: 파일 시스템의 정보
- 파일: inode 고유값과 자료구조에 의해 주요 정보 관리
  - '파일이름:inode'로 파일이름은 inode 번호로와 매칭
  - 파일 시스템에서는inode를 기반으로 파일 엑세스
  - inode 기반 메타 데이터 저장
### 3) 리눅스 파일 시스템(ext file sysyem)과 inode
- inode 기반 메타 데이터
  - 파일 권한
  - 소유자 정보
  - 파일 사이즈
  - 생성시간등 시간 관련 정보
  - 데이터 저장 위치등
### 4) 파일과 inode
- 리눅스 파일 탐색
  - /home/ubuntu/link.txt
    1. 각 디렉토리 엔트리(denty)를 탐색
      - 각 엔트리는 해당 디렉토리 파일/디렉토리 정보를 가지고 있음
    2. '/'dentry에서 'home'을 찾고, 'home'에서 'ubuntu'를 찾고, 'ubuntu'에서 link.txt 파일이름에 해당하는 inode를 얻음
### 5) 하드 링크와 소프트 링크
- cp 명령: 파일 복사
  - 1MB 사이즈를 가지고 있는 A파일 B파일로 복사
    - cp A B -> A와 B는 각각 물리적으로 10MB 파일로 저장
- 하드 링크: In A B
  - A와 B는 동일한 10MB 파일을 가리킴
  - 동일한 파일을 가진 이름을 하나 더 만든 것일 뿐
    - inode는 동일 
    - 전체 파일 용량은 달라지지 않음
  - ls -i(파일 inode 확인하기)
  - ls al(완전 동일한 파일)
  - rm A로 A를 삭제하면? B는 그래도 해당 파일 접근 가능
  - 'A:해당 inode'이 정보만 삭제되고, indoe를 가진 실제 파일은 그대로 남음
- 소프트(심볼릭) 링크: in -s A B
  - window OS읩 바로가기와 동일
  - ls -al 하면, 소프트 링크 확인 가능
  - rm A로 A를 삭제하면? B는 해당 파일 접근 불가
### 6) 특수 파일
- 디바이스
  - 블록 디바이스(Block Device)
    - HDD, CD/DVD와 같이 블록 또는 섹터 등 정해진 단위로 데이터 전송
    - IO 송수신 속도가 높음
  - 캐릭터 디바이스
    - 키보드, 마우스등 byte 단위 데이터 전송, IO 송수신 속도가 낮음

## 26-시스템 프로그래밍
### 1) 시스템 콜
- 운영체제 리소스나 서비스 요청을 위해 사용자 영역에서 커널 영역으로 들어가는 함수
- 주요 시스템 콜
  - read()
  - write()
  - open()
### 2) 구현
- eax 레지스터에 시스템 콜 번호를 넣음
- ebx 레지스터에는 시스템 콜에 해당하는 인자값 넣음
- 소프트 웨어 인터럽트 명령을 호출하면서 0x80값을 넘겨줌
  ```c
  mov eax, 1
  mov ebx, 0
  int 0x80
  ```
  1. CPU는 사용자 모드를 커널모드로 바꿈
  2. IDT에서 0x80에 해당하는 주소(함수)를 찾아서 실행
  3. system_call() 함수에서 eax로 부터 시스템 콜 번호를 찾아서 해당번호에 맞는 시스템콜 함수로 이동
  4. 해당 시스템콜 함수 실행 후, 다시 커널 모드에서 사용자모드로 변경하고, 다시해당 프로세스 다음 코드 진행
### 3) API
- 응용 프로그램과 분리된 하위 호환 인터페이스
  - 예: 시스템 콜 래퍼, 입출력 라이브러리 등
### 4) C라이브러리
- 유닉스 C라이브러리 - libc
- 리눅스 C라이브러리 - GNU libe- glibc(지립씨, 글립씨)
  - 시스템콜, 시스템콜 래퍼, 기본 응용 프로그램 기능 포함
### 5) C 컴파일러
- 유닉스 C 컴파일러 - cc
- 리눅스 C 컴파일러 - GNU cc-gcc
- 우분투 리눅스에 gcc 설치
  ```c
  sudo apt-get install gcc
  gcc --version
  gcc -o test.c test
  ```
### 6) ABI
- 응용 프로그램 바이너리 인터페이스
- 함수 실행 방식, 레지스터 활용, 시스템콜 실행, 라이브러리 링크 방식 등
- ABI가 호환되면 재컴파일 없이 동작
- 컴파일러, 링커(라이브러리 링크), 툴체인(컴파일러를 만드는 프로그램)에서 제공
### 7) POSIX
- 유닉스 시스템 프로그래밍 인터페이스 표준
- IEEE(Institute of Eletronic and Electionics Engineers)에서 표준화 시도
- 리차드 스톨만(자유소프트웨어 재단)이 POSIX를 표준안 이름으로 제안

## 27-프로세스ID
### 1) 특징
- 프로그램
  - 바이너리, 코드 이미지, 응용프로그램, Application, 실행 파일
- 프로세스
  - 실행 중인 프로그램(메모리 적재 + 프로세스 상태 정보 포함)
- 스레드
  - 리눅스 프로세스는 기본 스레드
    - 싱글스레드 프로세스: 기본 프로세스
    - 멀티스레드 프로세스: 여러 스레드 존재
- 프로세스 ID
  - pid, 각 프로세스는 해당 시점에 unique한 pid를 가짐
  - pid 최대 값은 32768
  - 부호형(signed) 16비트 정수값 사용
### 2) 프로세스 계층
- 최초 프로세스: init 프로세스, pid 1
- init 프로세스는 운영체제가 생성
- 다른 프로세스는 또 다른 프로세스로 부터 생성
  - 부모 프로세스, 자식 프로세스
- ppid 값이 부모 프로세스의 pid를 뜻함
### 3) 프로세스와 소유자 관리
- 리눅스 내부에서는 프로세스의 소유자(사용자)와 그룹을 UID/GID(정수)로 관리
- 사용자에 보여줄때에만 UID와 사용자이름 매핑 정보를 기반으로 사용자 이름으로 제공

## 28-프로세스 관리
### 1) 생성
- 기본 프로세스 생성 과정
  1. TEXT, DATA, BSS, HEAP, STACK의 공간을 생성
  2. 프로세스 이미지를 해당 공간에 업로드하고, 실행 시작
- 프로세스 계층
  - 다른 프로세스는 또다른 프로세스로부터 생성
  - 부모 프로세스, 자식 프로세스
### 2) fork() 시스템콜
- 새로운 프로세스 공간을 별도로 만듬
  - fork() 시스템콜을 호출한 프로세스(부모 프로세스) 공간을 모두 복사
    - 별도의 프로세스 공간을 만들고 부모 프로세스 공간의 데이터를 그대로 복사
- pid = fork()가 실행된 부모 프로세스와 동일한 자식 프로세스가 별도 메모리 공간에 생성
- 자식 프로세스 pid가 0으로 리턴, 부모 프로세스는 실제 pid 리턴
- 두 프로세스의 변수 및 PC(Program Count) 값은 동일
- 새로운 프로세스 공간을 별도로 만들고, fork() 시스템콜을 호출한 프로세스(부모 프로세스) 공간을 모두 복사한 후 fork() 시스템콜 이후 코드부터 실행
### 3) exec() 시스템콜
- exec() 시스템콜을 호출한 현재 프로세스 공간의 TEXT, DATA, BSS 영역을 새로운 프로세스의 이미지로 덮어씌움
  - 별도의 프로세스 공간을 만들지 않음 
- 파일 이름만 넘겨주면 프로세스 환경변수(path)에서 파일명(실행파일) 검색
- 파일명을 전체경로 포함 넘겨줌
- 환경변수(PATH 포함 가능)를 별도로 정의해서 넘겨줘야함
### 4) execve() 시스템콜
- 환경변수를 새로 생성하므로, 기존 사용자가 설정한 환경 변수값은 사용할 수 없음
  - envp에는 PATH를 설정하지 않았으므로, execve()에서 "/bin/ls"로 전체 경로를 써야, 실행 가능
### 5) execl() 시스템콜
- execl() 시스템콜을 실행시킨 프로세스 공간에 새로운 프로세스 이미지를 덮어씌우고, 새로운 프로세스를 실행
- perror() 함수가 호출된다는 의미는 새로운 프로세스 이미지로 덮어씌우는 작업이 실행되지 못했다는 의미
  - execl() 시스템콜 실행 실패
### 6) wait() 시스템콜
- wait() 함수를 사용하면, fork() 함수 호출시, 자식 프로세스가 종료할 때까지, 부모 프로세스가 기다림
- 자식 프로세스와 부모 프로세스의 동기화, 부모 프로세스가 자식 프로세스보다 먼저 죽는 경우를 막기 위해 사용(고아 프로세스)
- wait() 함수를 사용하면, fork() 함수 호출시, 자식 프로세스가 종료할 때까지, 부모 프로세스가 기다림
- 자식 프로세스가 종료되면, 좀비 프로세스가 되어, 해당 프로세스 조사를 위한 최소 정보만 가지고 있는 상태가 됨
- 완전히 끝나면, 해당 정보도 삭제돼, 부모 프로세스에 SIGCHLD 시그널이 보내짐
- wait() 리턴값
  - 에러가 발생한 경우
  - status 정보를 통해 기본적인 자식 프로세스 관련 정보를 확인할 수 있음
### 7) copy-on-write
- fork()는 새로운 프로세스 공간 생성 후, 기존 프로세스 공간복사
  - 4GB를 복사한다면, 프로세스 생성 시간이 오래 걸림
- 자식 프로세스 생성시, 부모 프로세스 페이지를 우선 사용
- 부모 또는 자식 프로세스가 해당 페이지를 읽기가 아닌, 쓰기를 할 때
  - 이 때 페이지를 복사하고, 분리함
- 장점
  - 프로세스 생성 시간을 줄일 수 있음
  - 새로 생성된 프로세스에 새롭게 할당되어야 하는 페이지 수도 최소화
- 자식 프로세스 생성시, 부모 프로세스 페이지를 우선 사용
- 부모 또는 자식 프로세스가 해당 페이지를 읽기가 아닌, 쓰기 처음 요청시, 페이지 복사 및 분리
### 8) 프로세스 종료
- exit() 시스템콜
  - 프로세스 종료
- main 함수의 return 0; 와 exit(0)의 차이는?
  - exit() 함수: 즉시 프로세스를 종료함(exit() 함수 다음에 있는 코드는 실행되지 않음)
  - return 0: 단지 main() 이라는 함수를 종료함
    - main()에서 return 시, C언어 실행 파일에 기본으로 포함된 _start() 함수를 호출하게 됨
    - 해당 함수는 결국 exit() 함수를 호출함
- exit() 시스템콜 주요 동작
  - atexit()에 등록된 함수 실행
  - 열려 있는 모든 입출력 스트림 버퍼 삭제
  - 프로세스가 오프한 파일을 모두 닫음
  - tmpfile() 함수를 통해 생성한 임시 파일 삭제
    - 참고: tmpfile() - 임시 파일을 wb+(쓸 수 있는 이진파일 형태) 모드로 오픈가능
- atexit() 함수
  - 프로세스 종료시 실행될 함수를 등록하기 위해 사용
  - 등록된 함수를 등록된 역순서대로 실행

## 29-프로세스 스케쥴링 
### 1) 우선순위 기반 스케쥴러
- nice()
  - 프로세스 중 root가 소유한 프로세스만, 우선순위를 높일 수 있음
    - 다른 프로세스는 우선순위를 낮출 수만 있음
    - 스케쥴링 방식에 따라 우선순위가 적용될 수도 있고, 안될 수도 있음
- getpriority(), setpriority()
  - which 프로세스, 프로세스 그룹, 사용자 별로 우선순위 가져옴
  - 예외 priority.c(root 소유로 실행)
    - 이오ㅣ에 스케쥴링 조작 시스템콜 기본 제공, 스케쥴링 알고리즘 변경으로 사용은 어려움

## 30-IPC
### 1) 파이프(pipe)
- 기본 파이프는 단방향 통신
- fork()로 자식 프로세스 만들었을 때, 부모와 자식 간의 통신
### 2) 메시지 큐(message queue)
- 어느 프로세스 간에라도 데이터 송수신 가능
- FIFO 정책으로 데이터 전송
### 3) 공뮤메모리(shared memory)
- 노골적으로 kernel space에 메모리 공간을 만듬, 해당 공간을 변수처럼 쓰는 방식
- message queue처럼 FIFO 방식이 아니라, 해당 메모리 주소를 마치 변수처럼 접근하는 방식
- 공유메모리 key를 가지고, 여러 프로세스가 접근 가능

## 31-시그널
### 1) 특징
- 본래 다른 용도이지만, IPC로도 사용가능한 기법
- 시그널(Signal)
  - 프로세스에 이벤트 전달
  - 유닉스에서 30년 이상 사용된 전통적인 기법
  - 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생됐는지를 알려주는 기법
- 소켓(Socket)
  - 네트워크
### 2) 주요 시그널
- 시그널 종류와 각 시그널에 따른 기본동작이 미리 정해져 있음
  시그널 | 종류
  --- | --- 
  SIGKILL | 프로세스 죽여라 <br>(슈퍼 관리자가 사용하는 시그널)
  SIGALARM | 알람 발생
  SIGSTP | 프로세스 멈춰라
  SIGCONT | 멈춰진 프로세스 실행
  SIGINT | 프로세스 인터럽트 보내서 죽여라
  SIGSEGV | 프로세스가 다른 메모리영역을 침범
### 3) 동작
- 프로그램에서 특정 시그널의 기본 동작 대신 다른 동작을 하도록 구현 가능
- 각 프로세스에서 시그널 처리위한 동작 설정 가능
  1. 시그널 무시
  2. 시그널 블록(블록을 푸는 순간, 해당 프로세스에서 시그널 처리)
  3. 프로그램 안에 등록된 시그널 핸들러로 재정의한 특정 동작 수행
  4. 등록된 시그널 핸들러가 없으면 커널에서 기본 동작 수행
### 4) 시그널과 프로세스
- PCB에 해당 프로세스가 블록 및 처리해야하는 시그널 관련 정보 관리
- 커널 모드에서 사용자 모드 전환시 시그널 정보 확인해서 처리

## 32-쉘스크립트
### 1) 특징
- 쉘을 사용해 프로그래밍 할 수 있음
- 서버 작업 자도화 및 운영(DevOps)을 위해 기본적으로는 익혀둘 필요가 있음
- 쉘 명령어를 기본으로 몇가지 문법이 추가된 형태
### 2) 기본문법
- 쉘스크립트는 파일로 작성 후 파일을 실행
- 파일의 가장 위으 첫 라인은 `#!/bin/bash`로 시작
- 쉘 스크립트 파일은 실행 권한을 가지고 있어야함
- 일반적으로 `파일이름.sh`와 같은 형태로 파일 이름을 작성
1. 출력문
  - echo "Hi" 
  - hi가 출력됨
2. 리스트 변수(배열)
  - 선언
    - 변수명 = (데이터1 데이터 2 등)
  - 사용
    - ${변수명[인덱스번호]}
### 3) 사전에 정의된 지역 변수
변수 | 설명
--- | ---
\$$ | 쉘의 프로세스 번호
\$0 | 쉘스크립트 이름
\$1 ~ $9 | 명령줄 인수
\$* | 모든 명령줄 인수리스트
\$# | 인수의 개수
\$? | 최근 실행한 명령어의 종료 값
  - 0(성공), 1~ 125(에러)
  - 126(파일이 실행 가능하지 않음)
  - 128 ~ 255
### 4) 연산자
- expr: 숫자 계산
- expr를 사용하는 경우 역작은 따옴를 사용해야함
- 연산자 *와 괄호() 앞엔 역슬래시()와 같이 사용
- 연산자와 숫자, 변수, 기호 사이에는 space를 넣어야함
### 5) 조건문
- 기본 if 구문
  - 명령문을 꼭 탭으로 띄워야 하는 것 아님
  ```bash
  if [조건]
  then
    명령문
  else
    명령문
  fi
  ```
### 6) 반복문
1. 기본 for 구문
    ```bash
    for 변수 in 변수값1 변수값2
    do
      명령문
    done
    ```
2. while
    ```bash
      while [조건문]
      do
        명령문
      done
      ```
### 7) 압축 명령 tar
1. 주요 옵션
      - x : 묶음 해제
      - c : 파일 묶음
      - v : 묶음 / 해제 과정을 화면 표시
      - z : gunzip 사용
      - f : 파일 이름을 지정