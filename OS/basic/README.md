# OS basic

## 01-운영체제(Operating System) 역할
### 1) 시스템 자원(System Resource)관리자
- 시스템 자원은 `컴퓨터 하드웨어`
  - CPU, Memory
  - I/0 Devices(입출력장치)
    - Monitor, Mouse, Keyboard, Network
  - 저장매체: SSD, HDD(Hard Disk)
### 2) 필요한 이유
> 컴퓨터 하드웨어는 스스로 할 수 있는 것은 없음
- CPU: 각 프로그램이 얼마나 CPU를 사용할지를 결정 못함
- Memory: 각 프로그램이 어느 주소에 저장되어야하는지, 어느정도 메모리에 확보해줘야 하는지 결정 못함
- 저장매체: 어떻게, 어디에 저장할지 결정 못함
- 입력장치: 스스로 무엇을 표시 못함
### 3) 대표적인 운영체제
- Window 
- Mac
- UNIX and LINUX
### 4) 역할
1. 응용프로그램 제어
2. 쉘 및 UI interface: GUI, Batch, Command Line
3. 시스템 콜(System Call)
4. 시스템 자원
   - 프로세스 관리(Process Management)
   - 주기억장치 관리(Main Memory Management)
   - 파일 관리(File Management)
   - 디스크 관리(Disk Management)
   - 입출력 관리(I/O Management)
   - 네트워킹 및 보호/보안(Networking, Protection)

## 02-응용 프로그램
### 1) 특징
- 소프트웨어는 운영체제, 엑셀 등 `다양한 프로그램`을 말함
### 2) 운영체제와 응용프로그램의 관계
- 운영체제의 응용 프로그램을 `관리`
  - 실행
  - 권환 관리
  - 관리자 권한으로 실행 
  - 사용자 관리(로그인)
### 3) 관리하는 이유
- 누구나 만들 수 있음(문제점)
  - 무한 반복문 등 잘 못 작성해 프로그램 다운
  - 모든 파일 삭제막기(권한/사용자 관리)
  - 한 프로그램이 CPU를 독점

## 03-운영체제 역사(Operating System History)
### 1) 1950년
1. ENIAC
    - 응용 프로그램이 `시스템 자원`을 제어
    - 첫 번째 컴퓨터
    - 운영체제가 없음
    - 1개의 프로그램 실행 바쁨
### 2) 1960년 초기
1. 배치 처리 시스템(Batch Processing System)
    - 여러 응용 프로그램을 등록시켜 순차적으로 실행한 시스템
    - 단점
      - 컴퓨터 응답시간(response time)이 오래 걸림
      - 실행 시간 오래 걸림(CPU 점유 문제 때문)
### 3) 1960년 후반
- 운영체제로 구현 되지 않음
- 시간을 잘 쪼개서, 여러 응용 프로그램 실행
  1. 시분할 시스템(Time Shareing System)
     - `다중 사용자` 지원
     - 컴퓨터 응답 시간 최소화한 시스템
  2. 멀티 태스킹(Multi Tasking)
     - 단일 CPU에서 `여러 응용프로그램`의 `병렬` 실행 가능
  3. 멀티프로그래밍
     - 최대한 CPU를 많이 활용한 시스템(시간대비 CPU 활용 높임)  
### 4) 1970년대 이전
- 어셈블러(Assembly)언어로 소프트웨어 개발
  - CPU(명령어), Memory(주소)
  - 컴퓨터마다 각각 커스텀 해줘야함
  - 프로그래밍 복잡도 높음
### 5) 1970년대
- 제대로된 운영체제 나옴!
- 컴파일러: 다시 작성할 필요 없음
- 프로그래밍 복잡도 낮음

  1. UNIX(유닉스) OS
  - 현대 운영체제의 기본기술을 모두 포함한 최초의 운영체제
  - 멀티태스킹, 시분할 시스템, 멀티 프로그래밍
    - 다중 사용자 지원
  - 미국 AT&T 사의 벨 연구소
    - 켄톰슨, 데니스리치: C언어 개바
### 6) 1980년대 
- 개인용 컴퓨터 시대
  - CLI: 터미널 환경(키보드, 검은화면)
  - GUI: GUI환경(마우스)
### 7) 1990년대
1. 응용프로그램 시대
   - 엑셀, 워드 프로세스
   - Window OS 대중화
2. 월드와이드 웹 인터넷 대중화
3. 오픈소스 운동 활성화
   - UNIX계열 OS + 응용프로그램 자체 개발, 소스오픈
   - LINUX 운영체제, 소스 오픈, 무료
### 8) 2000년대 이후
1. 오픈소스 활성화
   - 리눅스 운영체제
   - 아파치
   - MYSQL
   - 안드로이드 등
2. 병렬 처리
   - 가상머신
   - 대용량 처리 등 활성화

## 04-운영체제 구조
### 1) 시스템 콜
- 운영체제 기능을 호출하는 함수
- 운영체제가 제공 해줌
- API 내부에는 시스템 콜을 호출하는 형태로 만들어짐
- 커널 모드로 실행

### 2) 모드
1. 사용자 모드(User mode by applications)
  - 응용 프로그램이 사용(Level 3)
2. 커널 모드(kernel mode by OS)
  - OS가 사용(Level 0~2ß)s

## 05-스케쥴링
### 1) 배치 처리 시스템
- 일괄처리, 배치 처리, batch processing 이라고 부름
- 컴퓨터 프로그램 실행 요청 순서에 따라 순차적 프로그램 실행
- 한번에 등록된 여러 프로그램을 순차적 실행
### 2) 시분한 시스템
-`다중 사용자 지원`을 위해 컴퓨터 응답 시간을 최소화하는 시스템
### 3) 멀티태스킹
-`단일 CPU`에서 여러 응용프로그램이 동시에 실행 되는 것 처럼 `보이도록 하는 시스템`
- 10~20ms 단위로도 실행 응용프로그램이 바뀌는 구조
- 사용자에게는 동시에 실행되는 것처럼 보임
### 4) 멀티 프로세싱
- `여러 CPU`에 하나의 프로그램을 병렬로 실행하는 시스템
### 5) 멀티 프로그래밍
- `최대한 CPU`를 많이 활용하도록 하는 시스템
- 시간 대비 CPU 활용도 높일 수 있음
- 응용 프로그램을 짧은 시간 안에 실행 완료를 시킬 수 있음

## 06-스케쥴링 알고리즘
### 1) FIFO 스케쥴러
- CPU를 처음부터 끝까지 사용
- 가장 간단한 스케쥴러(배치 처리 시스템)
- FCFS(First Come First Served) 스케쥴러
### 2) SJF 스케쥴러
- Shortest Job First 스케쥴러
- 가장 프로세스 실행시간이 `짧은 프로세스`부터 실행 시키는 알고리즘
### 3) 우선순위 기반 스케쥴러
- Priority Based 스케쥴러
  - 정적 우선순위
    - 프로세스마다 우선순위를 미리 지정
  - 동적 우선순위
    - 스케쥴러가 상황에 따라 우선순위를 동적 변경
### 4) Round Robin 스케쥴러
- 시분할 시스템 기반
### 5) 기타
- 선점형 스케쥴러(Preemptive Scheduling)
  - 하나의 프로세스가 다른 프로세스 대신에 프로세스를 차지함
- 비선점형 스케쥴러(Non-preemptive Scheduling)
  - 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음

## 07-인터럽트
### 1) 특징
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치 및 예외 상황이 발생해 처리가 필요한 경우에 CPU에 알려서 처리하는 기술
### 2) 필요 이유
1. 선점형 스케쥴러 구현
   - 프로세스 running중에 스케쥴러가 이를 중단시킴
   - 다른 프로세스로 `교체`하기 위해 현 프로세스 실행 중단
   - 스케쥴러 코드가 실행이 돼 현 프로세스 실행 중지 시킴
2. IO Deviced와의 커뮤니케이션
   - 저장매체에서 데이터 처리완료시, 프로세스를 깨워야함
3. 예외 상황 핸들링
   - CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생할 경우, CPU가 해당 처리를 할 수 있도록 CPU에 알려줘야 함
### 3) 종류
1. 내부 인터럽트
   - 주로 프로그램 내부에서 잘못된 명령 또는 잘못된 데이터 사용시 발생
     - 0으로 나눴을 때
     - 사용자 모드에서 허용되지 않은 명령 또는 공간 접근시
     - 계산 결과가 Overflow/Underflow 날때
2. 외부 인터럽트
   - 주로 하드웨어에서 발생되는 이벤트(프로그램 외부)
     - 전원 이상
     - 기계문제
     - 키보드 등 IO 관련 이벤트
     - Timer 이벤트
3. 시스템 콜 인터럽트
  - 시스템콜 실행을 위해 강제로 코드에 인터럽트 명령 넣어 CPU 실행 시켜야함
  - 시스템 콜 실제 코드
    - eax 레지스터에 시스템 콜 번호를 넣고,
    - ebx 레지스터에는 시스템 콜에 해당하는 인자값을 넣고,
    - 소프트웨어 인터럽트 명령을 호출하면서 Ox80값을 넘겨줌
### 4) 처리 방식
- CPU가 프로그램을 실행 하고 있을 때
1. 입출력 하드웨어 등의 장치 이슈 발생
   - 파일 처리가 끝났다는 것을 운영체제에 알려주기
   - 운영체제는 해당 프로세스를 block state에서 실행 대기(ready) 상태로 프로세스 상태 변경하기
2. 예외 상황이 발생
   - 0으로 나누는 계산이 발생해 예외 발생을 운영체제에 알려줌
   - 운영체제가 해당 프로세스 실행 중지/ 에러 표시

## 08-프로세스 구조
### 1) 프로세스
1. stack 
  - 임시 데이터(함수 호출, 로컬 변수등)
2. heap
  - 코드에서 동적으로 만들어진 데이터
3. data
  - 변수/초기화된 데이터
4. text(Code)
  - 코드
### 2) Process Control Block(PCB)
- 프로세스가 실행 중인 상태를 캡쳐 및 구조화해 저장
1. Process ID
2. Register 값
  1. PC(Program Counter)
  2. SP(Stack Pointer)
3. Scheduiling Info(Process State)
4. Memory Info(메모리 사이즈 limit)

## 09-문맥교환(Context Switching)
### 1) 특징
- CPU에 실행할 프로세스를 교체하는 기술
  1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서 메인 메모리에 저장
  2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB 정보(PC, SP)를 CPU에 넣고, 실행
### 2) Cost
- Cache 초기화
- Memory Mapping 초기화
- Kernel은 항상 실행되어야 함.(메모리 접근 위해)
- 프로세스가 쓰레드 보다 비용이 많이 듬
  - 쓰레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문
  - 문맥교환이 발생시 Stack 영역만 변경을 진행하면 됨.

## 10-InterProcess Communication
### 1) 커뮤니케이션
- 커널 공간 활용(공유)
- 프로세스는 다른 프로세스의 `공간`을 접근할 수 없다.
- 다른 프로세스와 커뮤니케이션을 할 수 있도록 IPC를 제공함.
### 2) 통신에 필요한 이유
- 여러 프로세스를 만들어 동시 실행해 성능을 높임
- 이 때 프로세스간의 상태확인과 데이터 송수신이 필요함.
### 3) 방법
1. File 사용
2. Message Queue
3. Shared Memory
4. Pipe
5. Signal
6. Semaphore
7. Socket

## 11-스레드
### 1) 특징
- Light Weight Process라고도함.
- 하나의 프로세스에 여러개의 스레드 생성강
- 스레드들은 동시에 실행가능
- 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
- 멀티 스레드
  - 소프트웨어 병행 작업처리를 위해 멀티 스레드를 사용함
### 2) 장점
1. 사용자에 대한 응답성 향상
2. 자원 공유 효율
  - IPC 기법과 같이 프로세스간 자원 공유를 위해 번거로운 작업이 필요없음
  - 프로세스 안에 있으므로, 프로세스의 데이터를 모두 접근 가능
3. 작업이 분리돼 코드가 간결
### 3) 단점
1. 스레드 중 한 스레드만 문제가 있어도, 전체 프로세스가 영향을 받음
2. 스레드 많이 생성하면, Context Switching이 많이 일어나 성능 저하
  - 리눅스 OS는 Thread를 Process와 같이 다룸
### 4) 프로세스 vs 스레드
프로세스 | 스레드
--- | ---
독립적 | 프로세스의 서프셋
각각 자원가짐 | 프로세스의 자원 공유
자신만의 주소영역 가짐 | 주소영역 공유
IPC 기법으로 통신 | 필요 없음

## 12-동기화
### 1) 특징
- 작업들 사이에 실행 시기를 맞추는 것
- 여러 스레드가 동일한 자원 접근시 동기화 이슈 발생
  - 동일 자원을 여러 스레드가 동시 수정시, 각 스레드 결과에 영향을 줌
### 2) 이슈 해결 방안
- 상호배제
- 쓰레드는 프로세스 모든 데이터를 접근할 수 있음
  - 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요
  - 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막아라
### 3) Mutex와 세마포어
- Critical Section(임계구역)에 대한 접근을 막기 위해 Locking 메커니즘이 필요
1. Mutex(binary semapohore)
  - 임계구역에 하나의 스레드만 들어갈 수 있음
2. Semaphore
  - 임계구역에 여러 스레드가 들어갈 수 있음
  - counter를 두어서 동시에 리소스에 접근 할수 있는 허용가능한 스레드 수를 제어
  - P: 검사(임계영역에 들어갈 때)
    - s 값이 1이상이면, 임계 영역 진입 후, s값 1차감(s값이 0이면 대기)
  - V: 증가(임계영역에서 나올때)
    - s 값을 1더하고, 임계 영역을 나옴
  - S: 세마포어 값(초기 값 만큼 여러 프로세스가 동시 임계 영역 접근 가능)
  - 바쁜대기: wait()은 S가 0이라면, 임계영역에 들어가기 위해, 반복문 수행
  - 대기큐: S가 음수일 경우, 바쁜 대기 대신, 대기큐 넣음
  - 재실행: wakeup() 함수를 통해 대기큐에 있는 프로세스 재실행
  - 주요 함수
    - sem_open(): 세마포어를 생성
    - sem_wait(): 임계영역 접근 전, 세마포어를 잠그고, 세마포어가 잠겨 있다면, 풀릴 때까지 대기
    - sem_post(): 공유자원에 대한 접근이 끝났을 때 세마포어 잠금을 해제한다.

## 13-가상메모리
### 1) 특징
- 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음
- 메모리가 실제 메모리보다 많아 보이게 하는 기술
  - 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
  - 프로세스간 공간 분리로 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
### 2) 필요한 이유
- 하나의 프로세스만 실행 가능한 시스템
  1. 프로그램을 메모리로 로드
  2. 프로세스 실행
  3. 프로세스 종료(메모리 해제)
- 여러 프로세스 동시 실행 시스템
  1. 메모리 용량 부족 이슈
  2. 프로세스 메모리 영역간에 침범이슈
### 3) 구조
- 프로세스는 가상 주소를 사용하고 실제 해당 주소에서 데이터를 읽고 / 쓸대만 물리주소로 바꿔주면 됨.
  - 가상주소: 프로세스가 참조하는 주소
  - 물리주쇠: 실제 메모리 주소
- MMU
  - CPU에 코드 실행시, 가상 주소 메모리 접근이 필요할때, 해당 주소를 물리 주소 값으로 변환해 주는 하드웨어 장치

## 14-페이징 시스템
### 1) 특징
- 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭한 물리 주소 공간을 관리
- 하드웨어 지원이 필요
  - intel x86 시스템에서는 4kb, 2MB, 1GB지원
- 리눅스에서는 4KB로 paging
- 페이지 번호를 기반으로 가상 주소 / 물리 주소 매핑 정보를 기록 / 사용
### 2) 페이지 테이블
- 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
- 가상주소 v =(p,d)라면
  - p: 페이지 번호
  - d: 페이지 처음부터 얼마 떨어진 위치인지 
### 3) paging sysytem 동작
- 해당 프로세스에서 특정 가상 주소 엑세스를하려면
  - 해당 프로세스의 page table에 해당 가상 주소가 포함된 page번호가 있는지 확인
  - page 번호가 있으면 이 page가 매핑된 첫 물리 주소를 알아냄
### 4) MMU
- CPU는 가상 주소 접근시 
  - MMU 하드웨어 장치를 통해 물리 메모리 접근
- 프로세스 생성시, 페이지 테이블 정보 생성
  - PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리메모리에 적재
  - 프로세스 구동시, 해당 페이지 테이블 base 주소가 별도 레지스터에 저장(CR3)
  - CPU가 가상 주소 접근시, MMU가 페이지 테이블 base 주소를 접근해서, 물리 주소를 가져옴
### 5) 다중 단계 페이징 시스템
- 32bit 시스템에서 4KB페이지를 위한 페이징 시스템
  - 하위 12bit는 오프세
  - 상위 20bit가 페이징 번호이므로, 2의 20승개의 페이지 정보가 필요함
- 페이징 정보를 단계를 나누어 생성
  - 필요없는 페이지는 생성하지 않으면, 공간 절약가능
### 6) 페이징 시스템과 공유메모리
- 프로세스간 동일한 물리 주소를 가리킬 수 있음(공간 절약, 메모리 할당 시간 절약)
- 물리 주소 데이터 변경시
  - 물리 주소에 데이터 수정 시도시 물리주소를 복사할 수 있음(copy-on-write)
### 7) 요구 페이징
- 프로세스 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재함
  - 선행페이징의 반대 개념: 미리 프로세스 관련 모든 데이터를 메모리에 올려 놓고 실행하는 개념
  - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)
### 8) 페이지 폴트
- 어떤 페이지가 실제 물리 메모리에 없을 때 일어나는 인터럽트
- 운영체제가 page fault가 일어나면, 해당 페이지를 물리 메모리에 올림


## 15-페이징 교체 
### 1) 특징
- 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데, 물리 메모리가 다 차 있을 때 주로 발생
### 2) 교체 알고리즘
1. FIFO
  - 가장 먼저 들어온 페이지를 내림
2. OPT
  - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내림
  - 일반 OS에서 구현 불가
3. LPU
  - 가장 오래전에 사용된 페이지 교체
  - OPT 교체 알고리즘이 구현이 불가해 과거 기록을 기반으로 시도
4. LFU
  - 가장 적게 사용된 페이지 내림
5. NUR
  - LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
  - 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠(R,M)
### 3) 스레싱
- 반복적으로 페이지 폴트가 발생해 과도하게 페이지 교체 작업이 일어나, 실제로는 아무일도 하지 못하는 상황

## 16-세그멘테이션
### 1) 특징
- 가상 메모리를 서로 크기가 다른 논리적 단위인 세그먼트(Segment)로 분할
- 페이징 기법에서는 가상 메모리를 같은 크기의 블록으로 분할
  - X86 리얼모드 
    - CS(code Segment), DS(Data Segment), SS(Stack Segment),ES(Extra Segment)로 세그먼트를 나누어, 메모리 접근
- 크기가 다른 Segment 단위로 물리 메모리 로딩
- 하드웨어 지원 필요
- 외부 단편화
### 2) 세그먼트 가상죽소
- v = (s,d): s는 세그먼트 번호, d는 블록 내 세그먼트의 변위

## 17-파일시스템
### 1) 특징
- 동일한 시스템콜을 사용해 다양한 파일 시스템 지원 가능토록 구현
  - read/write 시스템 콜 호출시, 각 기기 및 파일 시스템에 따라 실질적인 처리를 담당
    - 예: read_spec/write_spec
  - 파일을 실제 어떻게 저장할지는 다를 수 있음
    - 리눅스의 경우 ext4외 NTFS, FAT32 파일 시스템 지원

    함수 | 의미
    --- | --- 
    open | 존재한 파일 읽기 또는 쓰기용<br>새로운 파일 생성해 연다
    creat | 새로운 파일을 생성해 연다
    close | open 또는 creat로 열려진 파일을 닫음
    read | 열려진 파일로 부터 데이터를 읽어 들임
    write | 열려진 파일에 데이터를 씀
    lseek | 파일 안에서 읽기/쓰기 포인터를 지정한 바이트 위치로 이동  
    unlink / remove | 파일을 삭제함
### 2) inode 방식 파일 시스템
- 파일 시스템 기본 구조
  - 수퍼블록: 파일 시스템 정보
  - 아이노드 블록: 파일 상세 정보
  - 데이터 블록: 실제 데이터
- 파일:inode 고유값과 자료구조에 의해 주요 정보관리
  - '파일이름: inodee'로 파일이름은 inode 번호와 매칭
  - 파일 시스템에서는 inode를 기반으로 파일 엑세스
  - inode 기반 메타 데이터 저장
- inode 기반 메타데이터
  - 파일 권한
  - 소유자 정보
  - 파일 사이즈
  - 생성 시간 
  - 데이터 저장 위치
### 3) 디렉토리 엔트리
- 리눅스 파일 탐색: 예- /home/ubuntu/link.txt
  - 각 디렉토리 엔트리(dentry)를 탐색
    - 각 엔트리는 해당 디렉토리 파일/디렉토리를 가지고 있음
  - '/' dentry에서 'home'을 찾고 
  - 'home'에서 'ubuntu'를 찾고
  - 'ubuntu에서 link.txt 파일이름에 해당 하는 inode를 얻음
### 4) 가상 파일 시스템(Virtual File System)
- Network등 다양한 기기도 동일한 파일 시스템 인터페이스를 통해 관리 기능
  - 예: read/write 시스템콜 사용, 각 기기별 read_spec/write_spec 코드 구현(운영체제 내부)

## 18-부팅
### 1) 특징
- 컴퓨터를 켜서 동작시키는 절차
- Boot 프로그램
  - 운영체제 커널을 Storage에서 특정 주소의 물리 메모리로 복사
  - 커널의 처음 실행위치로 PC를 가져다 놓는 프로그램
### 2) 부팅 과정
1. 컴퓨터 전원 버튼 클릭
2. BIOS가 특정 Storage 읽어와 bootstrap loader를 메모리에 올리고 실행
3. bootstrap loader 프로그램이 있는 곳을 찾아서 실행

## 19-가상 머신
### 1) 특징
- 하나의 하드웨어에 다수의 운영체제를 설치
- 개별 컴퓨터처럼 동작하도록 하는 프로그램
- Bare-Metal 방식이 가장 성능 좋음
  - 하드웨어 직접 엑세스 가능
  - AWS(클라우드 컴퓨팅)환경도 Bare-Metal 기반 가상 머신 기술활용(KVM)
### 2) 종류
1. Hardware에서 직접 구동
  - 운영체제와 응용프로그램을 물리적 하드웨어에서 분리하는 프로세스
  - 하이퍼바이저 또는 버추얼 머신 모니터(VMN)가 Hardware에서 직접 구동
    - Xen, KVM
2. Host OS 상위에 설치
  - VMWare, Parallels Desktop(mac)
### 3) 가상화
1. 전가상화
  - 각 가상머신이 하이퍼바이저를 통해서 하드웨어와 통신
    - 하이퍼바이저가 마치 하드웨어인 것처럼 동작
    - 가상머신의 OS는 자신이 가상 머신인 상태인지를 모름
2. 반가상화
  - 각 머신에서 직접 하드웨어와 통신
  - 각 가상머신에 설치된 OS는 가상 머신인 경우 각 명령에 하이퍼 바이저 명령을 추가해서 하드웨어와 통신
### 4) Docker
- 운영체제 레벨에서 별도로 분리된 실행환경을 제공(커널 추상화)
  - 리눅스 처음 설치했을때와 유사한 실행환경을 만들어 줌
  - 리눅스 컨테이너 기술로 macOs나 window에 설치할 경우는 가상 머신 기반 제공
  - Data Enginerring에서 Docker로 시스템 환경 설정 + 프로그램을 한번에 배포
    - 프로그램 업데이트 -> docker 이미지 작성 -> Jenkins로 배치잡 생성 및 실행