# Java Basic

## 01-자바 프로그래밍
### 1) 프로그래밍 이란
- 프로그래밍: 컴퓨터가 일을 수행 하도록 프로그래밍 언어로 명령어 프로그램을 만드는 일
- 컴파일: 프로그래밍 언어를 컴퓨터가 실행 가능한 기계어로 만드는일 
- 컴파일러: 기계어로 바꾸어주는 프로그램
### 2) 자바 역사
- 1991년 제임스 고슬링을 주축으로 선 마이크로 시스템 연구원들이 개발
- 가전, 휴대용 장치에 사용되는 소프트웨어 언어
### 3) 특징
- 플랫폼에 영향을 받지 않으므로 다양한 환경에 사용함
- 객체 지향 언어로 `유지보수`가 `쉽고` 확장성 좋음
- 프로그램이 `안정적`
- 풍부한 기능이 제공된 오픈소스
### 4) 좋은점
- 재사용성
- 유지보수
- 코드 관리
- 신뢰성 높은 프로그램
### 5) 객체 지향 프로그래밍이란?
- 프로그램의 구현을 시간 흐름순이 아닌 객체간의 관계와 협력을 기반으로 프로그램 하는 것
- Object oriented programming(OOP)이라고 함
- 사용하는 언어: Java, C++, C#, Python, Javascript 등 다수의 언어
### 6) 자바를 활용한 프로그래밍
- 웹 서버 구현
- 안드로이드 프로그래밍
- 게임 프로그래밍

## 02-컴퓨터 자료 표현
### 1) 2진수로 표현
- 0과 1로만 데이터를 저장
- bit(비트)
  - 컴퓨터가 표현하는 데이터의 최소 단위
  - 2진수 하나의 값을 저장할 수 있는 메모리 크기
- byte(바이트)
  - 1byte = 1bit
### 2) 비트로 나타낼 수 있는 수의 범위
- 한개의 비트
  - 0, 1(`2개`)
- 두개의 비트
  - 00, 01, 10, 11(`4개`)
- 세개의 비트
  - 000, 001, 010, 011, 100, 101, 110, 111 (`8개`)
### 3) 예제
- [2진수, 8진수, 16진수 사용](./code/Binary.java)

## 03-변수
### 1) 특징
- 항상 변하는 값
- 표현하려는 수에 맞는 데이터 타입 이용해 변수 선언

### 2) 변수명
- 영문자(대문자, 소문자)나 숫자를 사용 가능
- 특수문자는 $ _만 사용가능
- 변수이름 시작은 `숫자` 못함
- 자바의 `예약어`는 사용 못함

### 2) 예제
- [변수](./code/Variable.java)

## 04-자료형
### 1) 특징
- 변수 선언 후 자료형의 크기 만큼 메모리에 할당

  바이트 | 정수형 | 문자형 | 실수형 | 논리형
  --- | :---: | :---: | :---: | :---: |
  1바이트 | byte | - | - | boolean|
  2바이트 | short | char | - | - |
  4바이트 | int | - | float | - |
  8바이트 | long | - | double | - |

### 2) 정수형
1. byte
   - 1바이트 단위로 동영상, 음악 파일 등 실행 파일의 처리 할때 사용

2. short
   - 2바이트 단위로 C/C++ 언어와 호환시 사용 

3. int
   - 자바에서 기본 정수 자료형
   - 4바이트 단위 
   - 32비트 초과시 long 자료형으로 처리

4. long 
   - 8바이트 자료형
   - 숫자의 뒤에 알파벳 L 또는 l을 표시
     ```java
     long lnum = 10204023040L
     long lnum = 10204023040l
     ```
### 3) 실수형
1. 특징
   - 부동 소수점 방식 
     - 실수는 정수보다 정밀해서 다른 방식인 소수점을 표현함
2. float
   - 4바이트 자료형 
   - 실수 뒤 F를 삽입해야함
3. double
   - 8바이트 자료형
4. 부동소수점 방식의 오류
   - 지수와 가수로 나타내는 부동 소수점 방식에서는 지수부가 0을 표현 할 수 없기 때문에 약간의 오차가 발생 할 수 있음
### 4) 문자형
1. 특징
   - 문자도 정수로 표현함
   - 자바는 문자를 나타내기 위해 UNICODE를 사용 
2. char
   - 문자를 위한 데이터 타입으로 사용
3. 문자세트
   - 각문자를 어떤 값으로 표현 할지 코드 값을 모아 둔것
     - encoding
       - 문자가 숫자로 변환되는 것
     - decoding
       - 숫자에서 다시 문자로 변환되는 것
     - ASKII
       - 알파벳과 숫자 특수 문자등을 1바이트에 표현하는데 사용하는 문자세트 
     - UTF-8
       - 1바이트에 4바이트까지 다양하게 문자를 표현할 수 있음  
     - UTF-16
       - 2바이트로 문자를 표현
### 5) 논리형
 - 참과 거짓 두가지만 나타냄
 - 1바이트 사용
 - 값이 존재하는지, 배열이 비었는지 할 때 주로 사용
### 6) 상수
 - 상수는 변하지 않는 수
 - 예: 원주율 3.14 등
 - final 예약어를 사용해 선언
 - 상수를 사용하면 변하지 않는 값을 반복해 사용 가능
 - 의미 있는 문자로 인식 하기 쉬움
### 7) 리터럴
 - 프로그램에서 사용하는 숫자, 문자, 논리 값을 뜻함
 - 리터럴은 상수 풀(constant pool)에 있음
 - 정수 리터럴은 int로 실수 리터럴은 double로 저장됨
 - 정수의 범위가 넘어가는 경우 L,l 식별자 써야함
 - float로 사용 할 경운엔 F,f 식별자 써야함 
### 8) 형변환
- 서로 다른 자료형 간에 연산등의 수행을 위해 하나의 자료형으로 통일 하는 것
- 묵시적 형 변환과 명식적 형 변환 있음
- 바이트 크기가 작은 자료형에서 큰 자료형으로 형 변환은 자동
- 덜 정밀한 자료형에서 더 정밀한 자료형으로 형 변환은 자동

## 05-연산자
### 1) 항
- 연산에 사용되는 값
### 2) 연산자
- 항을 이용해 연산하는 기호
### 3) 대입 연산자
- 변수에 다른 변수나 값을 대입한 연산자
- 이항 연산자 중 우선순위가 가장 낮은 연산자들
- 왼쪽 변수 = 오른쪽 변수(또는 식, 값)
### 4) 부호 연산자
- 단항 연산자
- 변수의 부호를 유지 하거나(+) 바꿈(-)
- 실제 변수의 부호가 변하려면 대입 연사자를 사용해야함
### 5) 산술 연산자
- 사칙 연산자
   연산자 | 기능 | 예 
  :---: | :--- | :---: 
  \+ | 두 항 더함 | 5+3
  \- | 앞 항에서 뒤 항을 뺌 | 5-3
  \* | 두 항 곱 | 5*8 
  \/ | 앞 항에서 뒤 항을 나누어 몫을 구함 | 5/3
  \% | 앞 항에서 뒤 항을 나누어 나머지을 구함 | 5%3 
- % 나머지 구하는 연산자 
  - 숫자 n의 나머지 범위는 0 ~ -1
### 6) 복합 대입 연산자
- 대입 연산와 다른 연산자가 함께 쓰임

   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  \+= | 두 항의 값을 `더해` 왼쪽 항에 대입| num1 += 2; <br> num = num1 +2;
  \-= | 왼쪽 항에서 오른쪽 항을 `빼서` 그 값을 왼쪽 항에 대입 | num1 -= 2; <br> num = num1 - 2;
  \*= | 두 항의 값을 `곱`해 왼쪽 항에 대입 | num1 *= 2; <br> num = num1 * 2;
  \/= | 왼쪽 항을 오른쪽 항으로 나눠 그 `몫`을 왼쪽 항에 대입 | num1 /= 2; <br> num1 = num1/2; 
  \%= | 왼쪽 항을 오른쪽 항으로 나눠 그 `나머지`를 왼쪽 항에 대입 | num1 %= 2; <br> num1 = num1 % 2; 
  \<<= | `비트`를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입 | num1 <<= 2; <br> num1 = num1 << 2;
  \>>= | `비트`를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입 <br> 왼쪽에 채워지는 비트 값: `부호비트와 동일` | num1 >>= 2; <br> num1 = num1 >> 2;
  \>>>= | 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입 <br> - 왼쪽에 채워지는 비트 값: `0` | num1 >>>= 2; <br> num1 = num1 >>> 2;
  &= | 두 항의 `&` 비트 연산 후 그 값을 왼쪽 항에 대입 | num &= num2; <br> num1 = num1 & num2;
  \|= | 두 항의 `\|` 비트 연산 후 그 값을 왼쪽 항에 대입 | num \|= num2; <br> num1 \| num1 | num2;
  ^= | 두 항의 `^` 비트 연산 후 그 값을 왼쪽 항에 대입 | num &= num2; <br> num1 = num1 ^ num2;
### 7) 증감 연산자
- 단항연산자로 변수의 값에 1을 더하거나 뺌
- 연산자가 항의 앞에 있는가 뒤에 있는가에 따라 연산의 시점과 결과가 달라짐
- 문장의 끝을 기준으로 연산 시점을 생각해야함
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  ++ | 항의 값 1더함 | val = ++num; <br> - num에 1 증가한 후 val 변수 대입 <br> val = num++; <br> - val 변수에 num 값을 먼저 대입 후 num 값 1 증가
  -- | 항의 값 1뺌 | val = --num; <br> - num에 1 감소한 후 val 변수 대입 <br> val = num--; <br> - val 변수에 num 값을 먼저 대입 후 num 값 1 뺌
### 8) 관계 연산자
- 이항 연산자로 연산의 결과가 참과 거짓으로 반환됨
- 조건문, 반복문의 조건식으로 많이 사용
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  \> | 왼쪽 항이 크면 참, 아니면 거짓 반환 | num > 3;
  \< | 오른쪽 항이 크면 참, 아니면 거짓 반환 | num < 3;
  \>= | 왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓 반환 | num >= 3;
  \<= | 왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓 반환 | num <= 3;
  == | 두 개항의 값이 같으면 참, 아니면 거짓을 반환 | num == 3;
  != | 두 개항이 다르면 참, 아니면 거짓을 반환 | num != 3;  
### 9) 논리 연산자
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  &&(논리 곱) | 두 항이 모두 참인 경우에만 결과 값이 참, 아니면 거짓 | booleanval = (5>3) && (5<2);
  \|\|(논리 합) | 두 항 중 하나의 항만 참이면 결과 값이 참, 두항이 모든 거짓이면 결과 값 거짓 | booleanval = (5>3) \|\| (5<2);
  !(부정) | 단항 연산자로 참인 경우 거짓 변경, 거짓 경우 참으로 바꿈 | booleanval =!(5>3);
### 10) 조건 연산자
- 삼항 연산자로 조건식의 결과가 true(참)인 경우와 false(거짓)인 경우에 따라 다른 결과가 수행됨
- if(조건문)을 간단히 표현 할때 주로 사용
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  조건식 ? 결과1 : 결과2; | 조건식 `참`이면 결과1 <br> 조건식 `거짓`이면 결과2가 선택 | int num = (5>3) ? 10 : 20;
### 11) 비트 연산자
- 대입연산자와 다른 연산자가 함께 쓰임
- 마스크 : 특정 비트를 가리고 몇개의 비트 값만 사용할때
- 비트켜기: 특정 비트만을 1로 설정해 사용하고 싶을 때
- 비트끄기: 특정 비트만을 0으로 설정해 사용하고 싶을 때
- 비트 토글: 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 때
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  ~ | 비트의 반전(1의 보수) | a = ~a;
  & | 비트 단위 AND | 1 & 1 1반환 그 외는 0
  \| | 비트 단위 OR | 0\|0 0반환 그 외는 1
  ^ | 비트 단위 XOR | 두개의 비트가 서로 다른 경우에 1을 반환
  << | 왼쪽 shift | a<<2 변수 a를 2비트 만큼 왼쪽으로 이동
  \>> | 오른쪽 shift | a\>>2 변수 a를 2비트 만큼 오른쪽으로 이동
  \>>> | 오른쪽 shift | a\>>2 동일한 연산 <br> 채워지는 비트가 부호와 상관 없이 0

## 06-제어문
### 1) if문
- 주어진 조건에 따라 다른 실행이 이루어 지도록 구현
  ```java
  if(조건식){
    수행문1;
  } else if(조건식){
    수행문2; 
  } else {
    수행문3;
  }
  ```
### 2) switch-case 문
- 조건이 많을 경우 switch문을 씀.
- break문을 사용해 각 조건이 만족되면 switch 블럭을 빠져 나옴
  > 자바 14 부터 break 사용하지 않아도 됨
  ```java
  switch(변수){
    case 조건1: 조건2:
      수행문;
      break;
    default:
      수행문;
      break;
  }
  //14버젼
  switch(변수){
    case 조건1, 조건2->{
      수행문;
    }
    default->{
      수행문;
    }
  }
  ```

## 07-반복문
### 1) while문
- 조건이 참인 동안 반복 수행 
- 조건이 맞지 않으면 반복하던 수행을 멈추게 됨
- 조건은 주로 반복 횟수나 값의 비교의 결과에 따라 true, false 판단됨
  ```java
  while(조건식){
    수행문1
  }

  //무한반복
  while(true){
    수행문;
  }
  ```
### 2) do-while문
- 조건과 상관 없이 한번은 수행문을 수행
  ```java
  do {
    수행문1;
  } while(조건식){
    수행문2;
  }
  ```
### 3) for문
- 특정 수의 범위, 횟수와 관련해 반복되는 경주 씀
- 주로 배열과 함께 많이 사용
  ```java
  for(초기화식; 조건식; 증감식){
    수행문;
  }
  ```
## 08-break, continue 등
### 1) break
- 제어문의 블록을 빠져 나오는 기능
### 2) continue
- 반복문 내부에서 조건문와 같이 사용
- 조건이 맞는 경우 이후 반복문 블러 내부의 다른 수행문들을 수행하지 않음

## 09-객체지향
### 1) 객체(objcet)
- 의사나 행위가 미치는 대상
- 구체적, 추상적 데이터의 단위
### 2) 클래스 스타일
- 클래스는 대문자로 시작
- public 클래스와 .java 파일의 이름 동일함
- camel notaion 방식으로 명명
### 3) 클래스 구현 설명 및 멤버 변수 선언
1. 객체 정의
2. 각 객체의 속성을 멤버 변수로 역할을 메서드로 구현
3. 각 객체간의 협력을 구현
4. 예제
   - 학생클래스
     ```java
     public class Student{
       int studentNumber;
       String sutdentName;
       int majorCode;
       String majorName;
       int grade;
     }
     ```
   - 주문클래스
     ```java
     public class Order{
       int orderId;
       String buyerId;
       String sellerId;
       int productId;
       String orderDate;
     }
     ```
## 10-함수
### 1) 함수란
- 하나의 기능을 수행하는 일련의 코드
- 구현된 함수는 호출해 사용하고 호출된 함수는 기능이 끝나면 제어가 반환됨
- 함수로 구현된 하나의 여러 곳에서 동일한 방식으로 호출돼 사용 될 수 있음
### 2) 정의
- 함수는 이름, 매개변수 반환 값, 함수 몸체로 구성
  ```java
  int add(int num1, int num2){
    int result;
    result = num1 + num2;
    return result;
  }
  ```
- [예제](./code/Function.java)
### 3) 함수호출
- 함수가 호출 될때 지역 변수들이 사용하는 메모리를 `스택`이다.
- 함수의 수행이 끝나면 자동으로 반한 되는 메모리
### 4) 메서드
- 객체의 기능 구현하기 위해 클래스 내부에 구현되는 함수
- 멤버 함수(member funtion)
- 메서드를 구현함으로써 객체의 기능 구현됨
- 메서드의 이름은 그 객체를 사용하는 객체(클라이언트)에 맞게 짓는 것이 좋음
### 5) 예제
- 학생 이름과 주소를 받아서 메서드로 보여주기  
  - [학생클래스 정의](./code/Student)
  - [학생클래스 사용](./code/StudentTest)

## 11-인스턴스
### 1) 정의
- new 키워드를 사용해 클래스를 메모리에 생성한 상태
- 클래스는 객체의 속성 정의하고 기능 구현하여 만들어 놓은 코드 상태
- 실제 클래스 기반으로 생성된 객체(인스턴스)는 각각 다른 멤버 변수 값을 가지게 됨
- new 키워드를 사용해 인스턴스 생성
### 2) 힙 메모리
- 생성된 인스턴스는 동적 메모리(heap memory)에 할당
- 하나의 클래스로 부터 여러개의 인스턴스가 생성돼 각각 메모리 주소를 가지게됨

## 12-생성자
### 1) 특징
- 생성자 기본 문법 <class_name>([<argument_list]){[<statements]}
- 객체를 생성할 때 new 키워드와 함께 사용
- 생성자는 일반 함수처럼 기능 호출 하는 것이 아님
- 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출함
- 생성자는 반환 값이 없고, 클래스의 이름과 동일
- 대부분의 생성자는 외부에서 접근 간으하지만, 필요에 의해 private으로 선언되는 경우 있음
### 2) 기본생성자(default constructor)
- 클래스에는 반드시 적어도 하나 이상의 생성자가 존재
- 클래스에 생성자를 구현하지 않아도 new 키워드와 함께 생성자를 호출함
- 클래스에 생성자가 하나도 없는 경우 컴파일러가 생성자 코드를 넣어줌
- 매개 변수, 구현부 없음
### 3) 오버로딩(overloading)
- 생성자를 구현해서 사용함
- 클래스에 생성자를 따로 구현하면 기본 생성자는 제공 되지 않음
- 생성자를 호출하는 코드에서 여러 생성자 중 필요에 따라 호출해서 사용할 수 있음

### 4) 예제
1. 키가 180이고 몸무게가 78인 남성
   - [User](./code/User.java)
   - [UserTest](./code/UserTest.java)
  
2. 이름은 Tomas, 나이 37세, 주소는 서울
   - [Order](./code/Order.java)   
   - [OrderTest](./code/OrderTest.java)

## 13-참조자료형
1. 변수의 참조 자료형
    - String, Date 등
2. 기타
    - 클래스형으로 변수를 선언
    - 기본 자료형은 사용하는 메모리의 크기가 정해져 있지만, 참조 자료형은 클래스에 따라 다름
    - 참조 자료형을 사용 할때는 해당 변수에 대해 생성하여야함
3. 참조 자료형 정의해 사용하기
    - 학생이 수강한 과목들에 대한 성적을 산출하는 경우 학생 클래스 속성에 과목이 모두 있으면 불합리
    - 학생과 과목에 대한 클래스를 분리
    - 과목 클래스를 활용해 수강한 과목들의 변수 타입으로 선언
4. 3번 코드 작성
   - [학생 클래스](./code/Student.java)
   - [과목 클래스](./code/Subject.java)
   - [학생 클래스 실행](./code/StudentTest.java)

## 14-접근 제어 지시자
### 1) 특징
- 클래스 외부에서 클래스의 멤버 변수, 메서드 생성자를 사용 할 수 있는지 여부를 지정하는 키워드
  1. private
      - 같은 클래스 내부에서만 접근 가능(외부 클래스, 상속 관계의 클래스에서도 접근 불가)
  2. default
      - 같은 패키지 내부에서만 접근 가능(상속 관계라도 패키지가 다르면 접근 불가)
  3. protected
      - 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근 할 수 없음
  4. public 
      - 클래스의 외부 어디서나 접근 할 수 있음
### 2) get() / set() 매서드
- private으로 선언된 멤버 변수(필드)에 대해 접근, 수정할 수 있는 메서드를 public으로 제공
- get() 메서드만 제공 되는 경우 read-only 필드
### 3) 정보은닉
- 외부에서 접근 가능한 최소한 정보를 오픈해 객체의 오류를 방지 
- 클라이언트 객체가 더 효율적으로 객체를 활용 할 수 있음
- private으로 제어한 멤버 변수도 public 메서드가 제공되면 접근 가능
- private일 때 각 변수에 대한 제한을 public 메서드에서 제어할 수 있음
  
## 15-캡슐화
### 1) 특징
- 필요한 정보와 기능만 외부에 오픈
- 대부분의 멤버 변수와 메서드를 감춤
- 외부에 통합된 인터페이스만 제공해 일관된 기능 구현 하게함

## 16-this
### 1) 특징
- 객체 자신을 가리킴
- 생성자에서 또 다른 생성자를 호출 할때 사용
- 자신의 주소(참조값)을 반환함
- 생성된 인스턴스 메모리 주소를 가짐
- 클래스 내에서 참조변수가 가지는 주소 값과 동일한 주소값을 가지는 키워드
### 2) 생성자에서 다른 생성자를 호출
- 클래스에 생성자가 여러개인 경우, this를 이용해 생성자에서 다른 생성자를 호출 할 수 있음
- 생성자에서 다른 생성자를 호출 할때 인스턴스의 생성이 완전하지 않은 상태
- this() statement 이전에 다른 statement를 쓸수 없음

## 17-협력
### 1) 특징
- 객체 지향 프로그램에서 객체 간에는 협력이 이루어짐
- 협력을 위해 필요한 메세지를 전송해 이를 처리하는 기능을 구현해야함
- 매개 변수로 객체가 전달 될 경우 발생

## 18-static 변수
### 1) 공통으로 사용한 변수가 필요할때
- 여러 인스턴스가 공유한 기준 값이 필요한 경우
- 예를들어
  1. 회사 사번
  2. 학생 학번 
### 2) 메서드 만들기
- serialNum 변수를 private로 선언해 getter/setter 구현
- 인스턴슨 변수 사용 못함
- static 메서드는 인스턴스 생성과 무관해 클래스 이름으로 호출될 수 있음
- 인스턴슨 생성 전에 호출 될 수 있어 static 메서드 내부에서 인스턴스 변수를 사용 못함
### 3) 변수의 유효 범위와 메모리
- 변수의 유효 범위(scope)와 생성과 소멸(life cycle)은 각 변수 마다 다름
  변수 유형 | 선언 위치 | 사용 범위 | 메모리 | 생성과 소멸
  :---: | :--- | :--- | --- | --- |
  지역변수<br>(로컬변수) | 함수 내부에 선언 | 함수 내부 만 사용 | 스택 | 함수가 호출될 때 생성돼 함수가 끝나면 소멸함
  멤버변수<br>(인스턴스 변수) | 클래스 멤버 변수로 선언 | 클래스 내부에서 사용해 private이 아니면 참조 변수로 다른 클래스에서 사용 가능 | 힙 | 인스턴스가 생성될 때 힙에 생성돼, 가비지 컬렉터가 메모리 수거할때 소멸
  static 변수<br>(클래스 변수) | static 예약어를 사용해 클래스 내부에 선언 | 클래스 내부에서 사용해 private가 아니면 클래스 이름으로 다른 클래에서 사용 가능 | 데이터 영역 | 프로그램이 처음 시작할 때 상수와 함께 데이터 영역에 생성되고 프로그램이 끝나고 메모리를 해제할 때 소멸됨
- static 변수는 프로그램이 메모리에 있는 동안 계속 그 영역을 차지하므로 너무 큰 메모리를 할당하는 것은 좋지 않음
- 클래스 내부의 여러 메서드에서 사용하는 변수는 멤버 변수로 선언
- 멤버 변수가 너무 많으면 인스턴스 생성시 쓸데 없는 메모리 할당됨
- 상황에 적절하게 변수 사용
### 4) 싱글톤 패턴
- 프로그램에서 인스턴스가 단 한개만 생성하는 경우
- static 변수, 메서드를 활용해 구현함

## 19-배열
### 1) 특징
- 동일한 자료형의 순차적 자료구조
- 인덱스 연산자[]를 이용해 빠른 참조 가능
- 물리적 위치와 논리적 위치가 동일
- 배열의 순서는 0부터 시작
- 자바는 객체 배열을 구현한 ArrayList를 많이 활용
### 2) 배열 선언과 초기화
- 선언
  ```java
  int[] arrayOne = new int[10];
  int arrayTwo[] = new int[10];
  ```
- 초기화
  - 선언과 동시에 자료형에 따라 초기화됨
    - 정수: 0
    - 실수: 0.0
    - 객체: null
  - 필요에 따라 초기값 지정함
    ```java
    // 개수 생략해야함
    int[] numbers = new int[]{10,20,30}; 

    // new int[]생략 가능
    int[] numbers = {10,20,30};
    
    // 선언후 배열을 생성한 경우는 new int[] 생략 못함
    beforeNumbers = new int[]{10,20,30};
    ```
### 3) 배열 사용하기
- [] 인덱스 연산자 활용 - 배열 요소가 저장된 메모리의 위치를 연산해 찾아줌
- 배열을 이용해 합을 구하기
### 4) 배열의 길이와 요소의 개수는 동일하지 않음
- 배열을 선언하면 개수만큼 메모리가 할당됨
- 실제 요소(데이터)가 없는 경우도 있음
- 배열의 lenght 속성은 배열의 갯수를 반환해주기 때문에 요소의 갯수와 다름
- lenght를 활용해 오류가 나는 경우
### 5) 2차원 배열
- 이차원 이상으로 구현된 배열
- 평명(이차원 배열) 이나 공간(삼차원 배열)을 활용한 프로그램 구현
  ```java
  //자료형 배열이름      행개수 열개수
  int[][] arr = new int[2][30];
  ```
### 6) ArrayList
1. java.util 패키지에서 제공됨
      - 기존의 배열선언과 사용 방식은 배열의 길이를 정해 요소의 개수가 배열의 길이보다 커지면 배열을 재할당하고 복사함
      - 배열의 요소를 추가해 삭제하면 다른 요소들의 이동에 대한 구현을 해야함
      - ArrayList는 객체 배열을 좀 더 효율적으로 관리하기 위해 자바에서 제공해 주는 클래스
2. ArrayList의 주요 메서드
- | 메서드 | 설명 |
  | --- | --- |
  | boolean add(E e) | 요소 하나를 배열에 추가함<br>E는 요소의 자료형 의미
  | int size() | 배열에 추가된 요소 전체 갯수 반환 |
  | E get(int index) | 배열의 index 위치에 있는 요소값 반환 | 
  | E remove(int index) | 배열의 index 위치에 있는 요소 값을 제거해 그 값을 반환
  | boolean isEmpty() | 배열이 비어 있는지 확인

## 20-상속
### 1) 클래스 상속
- 새로운 클래스 정의 할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능 확장해 클래스 구현함
- 이미 구현된 클래스 보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 기존 클래스를 상속함
  - 상속하는 클래스: 상위 클래스, parent class, base class, super class
  - 상속받는 클래스: 하위 클래스, child class, derived class, sub class
### 2) 문법
- extends 키워드 뒤엔 단 하나의 클래스만 올 수 있음
- 자바는 단일 상속(single inheritance)만을 지원함
  ```java
  class B extends A {

  }
  ```
### 3) 상속 구현 하는 경우
- 상위 클래스는 하위 클래스 보다 더 일반적인 개념과 기능 가짐
- 하위 클래스는 상위 클래스 보다 더 구체적인 개념과 기능 가짐
- 하위 클래스가 상위 클래스의 속성과 기능을 확장(extends)한다는 의미
### 4) 상속을 활용한 클래스 구현
- protected 접근제어자
    - 상위 클래스에 선언된 private 멤버 변수는 하위 클래스에 접근 할 수 없음
    - 외부 클래스는 접근 할 수 없지만, 하위 클래스는 접근 할 수 있도록 protected 접근 제어자를 사용
### 5) 상속에서 클래스 생성 과정과 형변환
1. 하위 클래스가 생성되는 과정
    - 하위 클래스를 생성하면 상위 클래스가 먼저 생성됨
    - new VipCustomer()를 호출하면 Customer()가 먼저 호출됨
    - 클래스가 상속 받은 경우 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출함
2. super 키워드
    - 하위 클래스에서 가지는 상위 클래스에 대한 참조 값
    - super()는 상위 클래스의 기본 생성자를 호출함
    - 하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super()가 호출됨
    - 상위 클래스의 기본 생성자가 없느 경우(다른 생성자가 있는 경우) 하위 클래스에서는 생성자에서는 super를 이용해 명시적으로 상위 클래스의 생성자를 호출함
    - super는 생성된 상위클래스 인스턴스의 참조 값을 가지므로 super를 이용해 상위 클래스의 메서드나 멤버 변수에 접근함
3. 상속에서 인스턴스 메모리의 상태
    - 항상 상위 클래스의 인스턴스가 먼저 생성되고
    - 하위 클래스의 0인스턴스가 생성됨
### 6) 형 변환(업캐스팅)
- 상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스 생성
- 상위 클래스 타입의 변수에 하위 클래스 변수 대입
- 하위 클래스 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적 형 변환 가능함
- 상속 관계에서 모든 하위 클래스느 상위 클래스로 형 변환(업캐스팅)이됨

## 21-매서드 재정의하기(overring)
### 1) 하위 클래스에서 메서드 재정의하기
1. 오버라이딩(overriding)
    - 상위 클래스에 정의된 메서도의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름 메서드 재정의 할 수 있음
    - 재정의해 구현해야함
2. @overriding 애노테이션
    - 애노테이션은 원래 주석이라는 의미
    - 컴파일러에게 특별한 정보를 제공해주는 역할
         애노테이션 | 설명 | 
        :---: | :--- |
        @Override | 재정의된 메서드라는 정보 제공
        @Fuctionallnterface | 함수형 인터페이스라는 정보 제공
        @Deprecated | 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨
        @SuppressWarnings | 특정 경고가 나타나지 않도록 함<br>(예) @SupperWarnings("deprecation")는<br>@Deprecated가 나타나지 않도록함