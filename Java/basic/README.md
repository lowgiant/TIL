# Java Basic

## 01-자바 프로그래밍
### 1) 프로그래밍 이란
- 프로그래밍: 컴퓨터가 일을 수행 하도록 프로그래밍 언어로 명령어 프로그램을 만드는 일
- 컴파일: 프로그래밍 언어를 컴퓨터가 실행 가능한 기계어로 만드는일 
- 컴파일러: 기계어로 바꾸어주는 프로그램
### 2) 자바 역사
- 1991년 제임스 고슬링을 주축으로 선 마이크로 시스템 연구원들이 개발
- 가전, 휴대용 장치에 사용되는 소프트웨어 언어
### 3) 특징
- 플랫폼에 영향을 받지 않으므로 다양한 환경에 사용함
- 객체 지향 언어로 `유지보수`가 `쉽고` 확장성 좋음
- 프로그램이 `안정적`
- 풍부한 기능이 제공된 오픈소스
### 4) 좋은점
- 재사용성
- 유지보수
- 코드 관리
- 신뢰성 높은 프로그램
### 5) 객체 지향 프로그래밍이란?
- 프로그램의 구현을 시간 흐름순이 아닌 객체간의 관계와 협력을 기반으로 프로그램 하는 것
- Object oriented programming(OOP)이라고 함
- 사용하는 언어: Java, C++, C#, Python, Javascript 등 다수의 언어
### 6) 자바를 활용한 프로그래밍
- 웹 서버 구현
- 안드로이드 프로그래밍
- 게임 프로그래밍

## 02-컴퓨터 자료 표현
### 1) 2진수로 표현
- 0과 1로만 데이터를 저장
- bit(비트)
  - 컴퓨터가 표현하는 데이터의 최소 단위
  - 2진수 하나의 값을 저장할 수 있는 메모리 크기
- byte(바이트)
  - 1byte = 1bit
### 2) 비트로 나타낼 수 있는 수의 범위
- 한개의 비트
  - 0, 1(`2개`)
- 두개의 비트
  - 00, 01, 10, 11(`4개`)
- 세개의 비트
  - 000, 001, 010, 011, 100, 101, 110, 111 (`8개`)
### 3) 예제
- [2진수, 8진수, 16진수 사용](./code/Binary.java)

## 03-변수
### 1) 특징
- 항상 변하는 값
- 표현하려는 수에 맞는 데이터 타입 이용해 변수 선언

### 2) 변수명
- 영문자(대문자, 소문자)나 숫자를 사용 가능
- 특수문자는 $ _만 사용가능
- 변수이름 시작은 `숫자` 못함
- 자바의 `예약어`는 사용 못함

### 2) 예제
- [변수](./code/Variable.java)

## 04-자료형
### 1) 특징
- 변수 선언 후 자료형의 크기 만큼 메모리에 할당

  바이트 | 정수형 | 문자형 | 실수형 | 논리형
  --- | :---: | :---: | :---: | :---: |
  1바이트 | byte | - | - | boolean|
  2바이트 | short | char | - | - |
  4바이트 | int | - | float | - |
  8바이트 | long | - | double | - |

### 2) 정수형
1. byte
   - 1바이트 단위로 동영상, 음악 파일 등 실행 파일의 처리 할때 사용

2. short
   - 2바이트 단위로 C/C++ 언어와 호환시 사용 

3. int
   - 자바에서 기본 정수 자료형
   - 4바이트 단위 
   - 32비트 초과시 long 자료형으로 처리

4. long 
   - 8바이트 자료형
   - 숫자의 뒤에 알파벳 L 또는 l을 표시
     ```java
     long lnum = 10204023040L
     long lnum = 10204023040l
     ```
### 3) 실수형
1. 특징
   - 부동 소수점 방식 
     - 실수는 정수보다 정밀해서 다른 방식인 소수점을 표현함
2. float
   - 4바이트 자료형 
   - 실수 뒤 F를 삽입해야함
3. double
   - 8바이트 자료형
4. 부동소수점 방식의 오류
   - 지수와 가수로 나타내는 부동 소수점 방식에서는 지수부가 0을 표현 할 수 없기 때문에 약간의 오차가 발생 할 수 있음
### 4) 문자형
1. 특징
   - 문자도 정수로 표현함
   - 자바는 문자를 나타내기 위해 UNICODE를 사용 
2. char
   - 문자를 위한 데이터 타입으로 사용
3. 문자세트
   - 각문자를 어떤 값으로 표현 할지 코드 값을 모아 둔것
     - encoding
       - 문자가 숫자로 변환되는 것
     - decoding
       - 숫자에서 다시 문자로 변환되는 것
     - ASKII
       - 알파벳과 숫자 특수 문자등을 1바이트에 표현하는데 사용하는 문자세트 
     - UTF-8
       - 1바이트에 4바이트까지 다양하게 문자를 표현할 수 있음  
     - UTF-16
       - 2바이트로 문자를 표현
### 5) 논리형
 - 참과 거짓 두가지만 나타냄
 - 1바이트 사용
 - 값이 존재하는지, 배열이 비었는지 할 때 주로 사용
### 6) 상수
 - 상수는 변하지 않는 수
 - 예: 원주율 3.14 등
 - final 예약어를 사용해 선언
 - 상수를 사용하면 변하지 않는 값을 반복해 사용 가능
 - 의미 있는 문자로 인식 하기 쉬움
### 7) 리터럴
 - 프로그램에서 사용하는 숫자, 문자, 논리 값을 뜻함
 - 리터럴은 상수 풀(constant pool)에 있음
 - 정수 리터럴은 int로 실수 리터럴은 double로 저장됨
 - 정수의 범위가 넘어가는 경우 L,l 식별자 써야함
 - float로 사용 할 경운엔 F,f 식별자 써야함 
### 8) 형변환
- 서로 다른 자료형 간에 연산등의 수행을 위해 하나의 자료형으로 통일 하는 것
- 묵시적 형 변환과 명식적 형 변환 있음
- 바이트 크기가 작은 자료형에서 큰 자료형으로 형 변환은 자동
- 덜 정밀한 자료형에서 더 정밀한 자료형으로 형 변환은 자동

## 05-연산자
### 1) 항
- 연산에 사용되는 값
### 2) 연산자
- 항을 이용해 연산하는 기호
### 3) 대입 연산자
- 변수에 다른 변수나 값을 대입한 연산자
- 이항 연산자 중 우선순위가 가장 낮은 연산자들
- 왼쪽 변수 = 오른쪽 변수(또는 식, 값)
### 4) 부호 연산자
- 단항 연산자
- 변수의 부호를 유지 하거나(+) 바꿈(-)
- 실제 변수의 부호가 변하려면 대입 연사자를 사용해야함
### 5) 산술 연산자
- 사칙 연산자
   연산자 | 기능 | 예 
  :---: | :--- | :---: 
  \+ | 두 항 더함 | 5+3
  \- | 앞 항에서 뒤 항을 뺌 | 5-3
  \* | 두 항 곱 | 5*8 
  \/ | 앞 항에서 뒤 항을 나누어 몫을 구함 | 5/3
  \% | 앞 항에서 뒤 항을 나누어 나머지을 구함 | 5%3 
- % 나머지 구하는 연산자 
  - 숫자 n의 나머지 범위는 0 ~ -1
### 6) 복합 대입 연산자
- 대입 연산와 다른 연산자가 함께 쓰임

   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  \+= | 두 항의 값을 `더해` 왼쪽 항에 대입| num1 += 2; <br> num = num1 +2;
  \-= | 왼쪽 항에서 오른쪽 항을 `빼서` 그 값을 왼쪽 항에 대입 | num1 -= 2; <br> num = num1 - 2;
  \*= | 두 항의 값을 `곱`해 왼쪽 항에 대입 | num1 *= 2; <br> num = num1 * 2;
  \/= | 왼쪽 항을 오른쪽 항으로 나눠 그 `몫`을 왼쪽 항에 대입 | num1 /= 2; <br> num1 = num1/2; 
  \%= | 왼쪽 항을 오른쪽 항으로 나눠 그 `나머지`를 왼쪽 항에 대입 | num1 %= 2; <br> num1 = num1 % 2; 
  \<<= | `비트`를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입 | num1 <<= 2; <br> num1 = num1 << 2;
  \>>= | `비트`를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입 <br> 왼쪽에 채워지는 비트 값: `부호비트와 동일` | num1 >>= 2; <br> num1 = num1 >> 2;
  \>>>= | 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입 <br> - 왼쪽에 채워지는 비트 값: `0` | num1 >>>= 2; <br> num1 = num1 >>> 2;
  &= | 두 항의 `&` 비트 연산 후 그 값을 왼쪽 항에 대입 | num &= num2; <br> num1 = num1 & num2;
  \|= | 두 항의 `\|` 비트 연산 후 그 값을 왼쪽 항에 대입 | num \|= num2; <br> num1 \| num1 | num2;
  ^= | 두 항의 `^` 비트 연산 후 그 값을 왼쪽 항에 대입 | num &= num2; <br> num1 = num1 ^ num2;
### 7) 증감 연산자
- 단항연산자로 변수의 값에 1을 더하거나 뺌
- 연산자가 항의 앞에 있는가 뒤에 있는가에 따라 연산의 시점과 결과가 달라짐
- 문장의 끝을 기준으로 연산 시점을 생각해야함
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  ++ | 항의 값 1더함 | val = ++num; <br> - num에 1 증가한 후 val 변수 대입 <br> val = num++; <br> - val 변수에 num 값을 먼저 대입 후 num 값 1 증가
  -- | 항의 값 1뺌 | val = --num; <br> - num에 1 감소한 후 val 변수 대입 <br> val = num--; <br> - val 변수에 num 값을 먼저 대입 후 num 값 1 뺌
### 8) 관계 연산자
- 이항 연산자로 연산의 결과가 참과 거짓으로 반환됨
- 조건문, 반복문의 조건식으로 많이 사용
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  \> | 왼쪽 항이 크면 참, 아니면 거짓 반환 | num > 3;
  \< | 오른쪽 항이 크면 참, 아니면 거짓 반환 | num < 3;
  \>= | 왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓 반환 | num >= 3;
  \<= | 왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓 반환 | num <= 3;
  == | 두 개항의 값이 같으면 참, 아니면 거짓을 반환 | num == 3;
  != | 두 개항이 다르면 참, 아니면 거짓을 반환 | num != 3;  
### 9) 논리 연산자
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  &&(논리 곱) | 두 항이 모두 참인 경우에만 결과 값이 참, 아니면 거짓 | booleanval = (5>3) && (5<2);
  \|\|(논리 합) | 두 항 중 하나의 항만 참이면 결과 값이 참, 두항이 모든 거짓이면 결과 값 거짓 | booleanval = (5>3) \|\| (5<2);
  !(부정) | 단항 연산자로 참인 경우 거짓 변경, 거짓 경우 참으로 바꿈 | booleanval =!(5>3);
### 10) 조건 연산자
- 삼항 연산자로 조건식의 결과가 true(참)인 경우와 false(거짓)인 경우에 따라 다른 결과가 수행됨
- if(조건문)을 간단히 표현 할때 주로 사용
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  조건식 ? 결과1 : 결과2; | 조건식 `참`이면 결과1 <br> 조건식 `거짓`이면 결과2가 선택 | int num = (5>3) ? 10 : 20;
### 11) 비트 연산자
- 대입연산자와 다른 연산자가 함께 쓰임
- 마스크 : 특정 비트를 가리고 몇개의 비트 값만 사용할때
- 비트켜기: 특정 비트만을 1로 설정해 사용하고 싶을 때
- 비트끄기: 특정 비트만을 0으로 설정해 사용하고 싶을 때
- 비트 토글: 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 때
   연산자 | 기능 | 예 
  :---: | :--- | :--- 
  ~ | 비트의 반전(1의 보수) | a = ~a;
  & | 비트 단위 AND | 1 & 1 1반환 그 외는 0
  \| | 비트 단위 OR | 0\|0 0반환 그 외는 1
  ^ | 비트 단위 XOR | 두개의 비트가 서로 다른 경우에 1을 반환
  << | 왼쪽 shift | a<<2 변수 a를 2비트 만큼 왼쪽으로 이동
  \>> | 오른쪽 shift | a\>>2 변수 a를 2비트 만큼 오른쪽으로 이동
  \>>> | 오른쪽 shift | a\>>2 동일한 연산 <br> 채워지는 비트가 부호와 상관 없이 0

## 06-제어문
### 1) if문
- 주어진 조건에 따라 다른 실행이 이루어 지도록 구현
  ```java
  if(조건식){
    수행문1;
  } else if(조건식){
    수행문2; 
  } else {
    수행문3;
  }
  ```
### 2) switch-case 문
- 조건이 많을 경우 switch문을 씀.
- break문을 사용해 각 조건이 만족되면 switch 블럭을 빠져 나옴
  > 자바 14 부터 break 사용하지 않아도 됨
  ```java
  switch(변수){
    case 조건1: 조건2:
      수행문;
      break;
    default:
      수행문;
      break;
  }
  //14버젼
  switch(변수){
    case 조건1, 조건2->{
      수행문;
    }
    default->{
      수행문;
    }
  }
  ```

## 07-반복문
### 1) while문
- 조건이 참인 동안 반복 수행 
- 조건이 맞지 않으면 반복하던 수행을 멈추게 됨
- 조건은 주로 반복 횟수나 값의 비교의 결과에 따라 true, false 판단됨
  ```java
  while(조건식){
    수행문1
  }

  //무한반복
  while(true){
    수행문;
  }
  ```
### 2) do-while문
- 조건과 상관 없이 한번은 수행문을 수행
  ```java
  do {
    수행문1;
  } while(조건식){
    수행문2;
  }
  ```
### 3) for문
- 특정 수의 범위, 횟수와 관련해 반복되는 경주 씀
- 주로 배열과 함께 많이 사용
  ```java
  for(초기화식; 조건식; 증감식){
    수행문;
  }
  ```
## 08-break, continue 등
### 1) break
- 제어문의 블록을 빠져 나오는 기능
### 2) continue
- 반복문 내부에서 조건문와 같이 사용
- 조건이 맞는 경우 이후 반복문 블러 내부의 다른 수행문들을 수행하지 않음

## 09-객체지향
### 1) 객체(objcet)
- 의사나 행위가 미치는 대상
- 구체적, 추상적 데이터의 단위
### 2) 클래스 스타일
- 클래스는 대문자로 시작
- public 클래스와 .java 파일의 이름 동일함
- camel notaion 방식으로 명명
### 3) 클래스 구현 설명 및 멤버 변수 선언
1. 객체 정의
2. 각 객체의 속성을 멤버 변수로 역할을 메서드로 구현
3. 각 객체간의 협력을 구현
4. 예제
   - 학생클래스
     ```java
     public class Student{
       int studentNumber;
       String sutdentName;
       int majorCode;
       String majorName;
       int grade; 
     }
     ```
   - 주문클래스
     ```java
     public class Order{
       int orderId;
       String buyerId;
       String sellerId;
       int productId;
       String orderDate;
     }
     ```
## 10-함수
### 1) 함수란
- 하나의 기능을 수행하는 일련의 코드
- 구현된 함수는 호출해 사용하고 호출된 함수는 기능이 끝나면 제어가 반환됨
- 함수로 구현된 하나의 여러 곳에서 동일한 방식으로 호출돼 사용 될 수 있음
### 2) 정의
- 함수는 이름, 매개변수 반환 값, 함수 몸체로 구성
  ```java
  int add(int num1, int num2){
    int result;
    result = num1 + num2;
    return result;
  }
  ```
- [예제](./code/Function.java)
### 3) 함수호출
- 함수가 호출 될때 지역 변수들이 사용하는 메모리를 `스택`이다.
- 함수의 수행이 끝나면 자동으로 반한 되는 메모리
### 4) 메서드
- 객체의 기능 구현하기 위해 클래스 내부에 구현되는 함수
- 멤버 함수(member funtion)
- 메서드를 구현함으로써 객체의 기능 구현됨
- 메서드의 이름은 그 객체를 사용하는 객체(클라이언트)에 맞게 짓는 것이 좋음
### 5) 예제
- 학생 이름과 주소를 받아서 메서드로 보여주기  
  - [학생클래스 정의](./code/Student)
  - [학생클래스 사용](./code/StudentTest)

## 11-인스턴스
### 1) 정의
- new 키워드를 사용해 클래스를 메모리에 생성한 상태
- 클래스는 객체의 속성 정의하고 기능 구현하여 만들어 놓은 코드 상태
- 실제 클래스 기반으로 생성된 객체(인스턴스)는 각각 다른 멤버 변수 값을 가지게 됨
- new 키워드를 사용해 인스턴스 생성
### 2) 힙 메모리
- 생성된 인스턴스는 동적 메모리(heap memory)에 할당
- 하나의 클래스로 부터 여러개의 인스턴스가 생성돼 각각 메모리 주소를 가지게됨

## 12-생성자
### 1) 특징
- 생성자 기본 문법 <class_name>([<argument_list]){[<statements]}
- 객체를 생성할 때 new 키워드와 함께 사용
- 생성자는 일반 함수처럼 기능 호출 하는 것이 아님
- 객체가 생성될 때 변수나 상수를 초기화 하거나 다른 초기화 기능을 수행하는 메서드를 호출함
- 생성자는 반환 값이 없고, 클래스의 이름과 동일
- 대부분의 생성자는 외부에서 접근 간으하지만, 필요에 의해 private으로 선언되는 경우 있음
### 2) 기본생성자(default constructor)
- 클래스에는 반드시 적어도 하나 이상의 생성자가 존재
- 클래스에 생성자를 구현하지 않아도 new 키워드와 함께 생성자를 호출함
- 클래스에 생성자가 하나도 없는 경우 컴파일러가 생성자 코드를 넣어줌
- 매개 변수, 구현부 없음
### 3) 오버로딩(overloading)
- 생성자를 구현해서 사용함
- 클래스에 생성자를 따로 구현하면 기본 생성자는 제공 되지 않음
- 생성자를 호출하는 코드에서 여러 생성자 중 필요에 따라 호출해서 사용할 수 있음

### 4) 예제
1. 키가 180이고 몸무게가 78인 남성
   - [User](./code/User.java)
   - [UserTest](./code/UserTest.java)
  
2. 이름은 Tomas, 나이 37세, 주소는 서울
   - [Order](./code/Order.java)   
   - [OrderTest](./code/OrderTest.java)

## 13-참조자료형
1. 변수의 참조 자료형
    - String, Date 등
2. 기타
    - 클래스형으로 변수를 선언
    - 기본 자료형은 사용하는 메모리의 크기가 정해져 있지만, 참조 자료형은 클래스에 따라 다름
    - 참조 자료형을 사용 할때는 해당 변수에 대해 생성하여야함
3. 참조 자료형 정의해 사용하기
    - 학생이 수강한 과목들에 대한 성적을 산출하는 경우 학생 클래스 속성에 과목이 모두 있으면 불합리
    - 학생과 과목에 대한 클래스를 분리
    - 과목 클래스를 활용해 수강한 과목들의 변수 타입으로 선언
4. 3번 코드 작성
   - [학생 클래스](./code/Student.java)
   - [과목 클래스](./code/Subject.java)
   - [학생 클래스 실행](./code/StudentTest.java)

## 14-접근 제어 지시자
### 1) 특징
- 클래스 외부에서 클래스의 멤버 변수, 메서드 생성자를 사용 할 수 있는지 여부를 지정하는 키워드
  1. private
      - 같은 클래스 내부에서만 접근 가능(외부 클래스, 상속 관계의 클래스에서도 접근 불가)
  2. default
      - 같은 패키지 내부에서만 접근 가능(상속 관계라도 패키지가 다르면 접근 불가)
  3. protected
      - 같은 패키지나 상속관계의 클래스에서 접근 가능하고 그 외 외부에서는 접근 할 수 없음
  4. public 
      - 클래스의 외부 어디서나 접근 할 수 있음
### 2) get() / set() 매서드
- private으로 선언된 멤버 변수(필드)에 대해 접근, 수정할 수 있는 메서드를 public으로 제공
- get() 메서드만 제공 되는 경우 read-only 필드
### 3) 정보은닉
- 외부에서 접근 가능한 최소한 정보를 오픈해 객체의 오류를 방지 
- 클라이언트 객체가 더 효율적으로 객체를 활용 할 수 있음
- private으로 제어한 멤버 변수도 public 메서드가 제공되면 접근 가능
- private일 때 각 변수에 대한 제한을 public 메서드에서 제어할 수 있음
  
## 15-캡슐화
### 1) 특징
- 필요한 정보와 기능만 외부에 오픈
- 대부분의 멤버 변수와 메서드를 감춤
- 외부에 통합된 인터페이스만 제공해 일관된 기능 구현 하게함

## 16-this
### 1) 특징
- 객체 자신을 가리킴
- 생성자에서 또 다른 생성자를 호출 할때 사용
- 자신의 주소(참조값)을 반환함
- 생성된 인스턴스 메모리 주소를 가짐
- 클래스 내에서 참조변수가 가지는 주소 값과 동일한 주소값을 가지는 키워드
### 2) 생성자에서 다른 생성자를 호출
- 클래스에 생성자가 여러개인 경우, this를 이용해 생성자에서 다른 생성자를 호출 할 수 있음
- 생성자에서 다른 생성자를 호출 할때 인스턴스의 생성이 완전하지 않은 상태
- this() statement 이전에 다른 statement를 쓸수 없음

## 17-협력
### 1) 특징
- 객체 지향 프로그램에서 객체 간에는 협력이 이루어짐
- 협력을 위해 필요한 메세지를 전송해 이를 처리하는 기능을 구현해야함
- 매개 변수로 객체가 전달 될 경우 발생

## 18-static 변수
### 1) 공통으로 사용한 변수가 필요할때
- 여러 인스턴스가 공유한 기준 값이 필요한 경우
- 예를들어
  1. 회사 사번
  2. 학생 학번 
### 2) 메서드 만들기
- serialNum 변수를 private로 선언해 getter/setter 구현
- 인스턴슨 변수 사용 못함
- static 메서드는 인스턴스 생성과 무관해 클래스 이름으로 호출될 수 있음
- 인스턴슨 생성 전에 호출 될 수 있어 static 메서드 내부에서 인스턴스 변수를 사용 못함
### 3) 변수의 유효 범위와 메모리
- 변수의 유효 범위(scope)와 생성과 소멸(life cycle)은 각 변수 마다 다름
  변수 유형 | 선언 위치 | 사용 범위 | 메모리 | 생성과 소멸
  :---: | :--- | :--- | --- | --- |
  지역변수<br>(로컬변수) | 함수 내부에 선언 | 함수 내부 만 사용 | 스택 | 함수가 호출될 때 생성돼 함수가 끝나면 소멸함
  멤버변수<br>(인스턴스 변수) | 클래스 멤버 변수로 선언 | 클래스 내부에서 사용해 private이 아니면 참조 변수로 다른 클래스에서 사용 가능 | 힙 | 인스턴스가 생성될 때 힙에 생성돼, 가비지 컬렉터가 메모리 수거할때 소멸
  static 변수<br>(클래스 변수) | static 예약어를 사용해 클래스 내부에 선언 | 클래스 내부에서 사용해 private가 아니면 클래스 이름으로 다른 클래에서 사용 가능 | 데이터 영역 | 프로그램이 처음 시작할 때 상수와 함께 데이터 영역에 생성되고 프로그램이 끝나고 메모리를 해제할 때 소멸됨
- static 변수는 프로그램이 메모리에 있는 동안 계속 그 영역을 차지하므로 너무 큰 메모리를 할당하는 것은 좋지 않음
- 클래스 내부의 여러 메서드에서 사용하는 변수는 멤버 변수로 선언
- 멤버 변수가 너무 많으면 인스턴스 생성시 쓸데 없는 메모리 할당됨
- 상황에 적절하게 변수 사용
### 4) 싱글톤 패턴
- 프로그램에서 인스턴스가 단 한개만 생성하는 경우
- static 변수, 메서드를 활용해 구현함

## 19-배열
### 1) 특징
- 동일한 자료형의 순차적 자료구조
- 인덱스 연산자[]를 이용해 빠른 참조 가능
- 물리적 위치와 논리적 위치가 동일
- 배열의 순서는 0부터 시작
- 자바는 객체 배열을 구현한 ArrayList를 많이 활용
### 2) 배열 선언과 초기화
- 선언
  ```java
  int[] arrayOne = new int[10];
  int arrayTwo[] = new int[10];
  ```
- 초기화
  - 선언과 동시에 자료형에 따라 초기화됨
    - 정수: 0
    - 실수: 0.0
    - 객체: null
  - 필요에 따라 초기값 지정함
    ```java
    // 개수 생략해야함
    int[] numbers = new int[]{10,20,30}; 

    // new int[]생략 가능
    int[] numbers = {10,20,30};
    
    // 선언후 배열을 생성한 경우는 new int[] 생략 못함
    beforeNumbers = new int[]{10,20,30};
    ```
### 3) 배열 사용하기
- [] 인덱스 연산자 활용 - 배열 요소가 저장된 메모리의 위치를 연산해 찾아줌
- 배열을 이용해 합을 구하기
### 4) 배열의 길이와 요소의 개수는 동일하지 않음
- 배열을 선언하면 개수만큼 메모리가 할당됨
- 실제 요소(데이터)가 없는 경우도 있음
- 배열의 lenght 속성은 배열의 갯수를 반환해주기 때문에 요소의 갯수와 다름
- lenght를 활용해 오류가 나는 경우
### 5) 2차원 배열
- 이차원 이상으로 구현된 배열
- 평명(이차원 배열) 이나 공간(삼차원 배열)을 활용한 프로그램 구현
  ```java
  //자료형 배열이름      행개수 열개수
  int[][] arr = new int[2][30];
  ```
### 6) ArrayList
1. java.util 패키지에서 제공됨
      - 기존의 배열선언과 사용 방식은 배열의 길이를 정해 요소의 개수가 배열의 길이보다 커지면 배열을 재할당하고 복사함
      - 배열의 요소를 추가해 삭제하면 다른 요소들의 이동에 대한 구현을 해야함
      - ArrayList는 객체 배열을 좀 더 효율적으로 관리하기 위해 자바에서 제공해 주는 클래스
2. ArrayList의 주요 메서드
- | 메서드 | 설명 |
  | --- | --- |
  | boolean add(E e) | 요소 하나를 배열에 추가함<br>E는 요소의 자료형 의미
  | int size() | 배열에 추가된 요소 전체 갯수 반환 |
  | E get(int index) | 배열의 index 위치에 있는 요소값 반환 | 
  | E remove(int index) | 배열의 index 위치에 있는 요소 값을 제거해 그 값을 반환
  | boolean isEmpty() | 배열이 비어 있는지 확인

## 20-상속
### 1) 클래스 상속
- 새로운 클래스 정의 할 때 이미 구현된 클래스를 상속 받아서 속성이나 기능 확장해 클래스 구현함
- 이미 구현된 클래스 보다 더 구체적인 기능을 가진 클래스를 구현해야 할때 기존 클래스를 상속함
  - 상속하는 클래스: 상위 클래스, parent class, base class, super class
  - 상속받는 클래스: 하위 클래스, child class, derived class, sub class
### 2) 문법
- extends 키워드 뒤엔 단 하나의 클래스만 올 수 있음
- 자바는 단일 상속(single inheritance)만을 지원함
  ```java
  class B extends A {

  }
  ```
### 3) 상속 구현 하는 경우
- 상위 클래스는 하위 클래스 보다 더 일반적인 개념과 기능 가짐
- 하위 클래스는 상위 클래스 보다 더 구체적인 개념과 기능 가짐
- 하위 클래스가 상위 클래스의 속성과 기능을 확장(extends)한다는 의미
### 4) 상속을 활용한 클래스 구현
- protected 접근제어자
    - 상위 클래스에 선언된 private 멤버 변수는 하위 클래스에 접근 할 수 없음
    - 외부 클래스는 접근 할 수 없지만, 하위 클래스는 접근 할 수 있도록 protected 접근 제어자를 사용
### 5) 상속에서 클래스 생성 과정과 형변환
1. 하위 클래스가 생성되는 과정
    - 하위 클래스를 생성하면 상위 클래스가 먼저 생성됨
    - new VipCustomer()를 호출하면 Customer()가 먼저 호출됨
    - 클래스가 상속 받은 경우 하위 클래스의 생성자에서는 반드시 상위 클래스의 생성자를 호출함
2. super 키워드
    - 하위 클래스에서 가지는 상위 클래스에 대한 참조 값
    - super()는 상위 클래스의 기본 생성자를 호출함
    - 하위 클래스에서 명시적으로 상위 클래스의 생성자를 호출하지 않으면 super()가 호출됨
    - 상위 클래스의 기본 생성자가 없느 경우(다른 생성자가 있는 경우) 하위 클래스에서는 생성자에서는 super를 이용해 명시적으로 상위 클래스의 생성자를 호출함
    - super는 생성된 상위클래스 인스턴스의 참조 값을 가지므로 super를 이용해 상위 클래스의 메서드나 멤버 변수에 접근함
3. 상속에서 인스턴스 메모리의 상태
    - 항상 상위 클래스의 인스턴스가 먼저 생성되고
    - 하위 클래스의 0인스턴스가 생성됨
### 6) 형 변환(업캐스팅)
- 상위 클래스로 변수를 선언하고 하위 클래스의 생성자로 인스턴스 생성
- 상위 클래스 타입의 변수에 하위 클래스 변수 대입
- 하위 클래스 상위 클래스의 타입을 내포하고 있으므로 상위 클래스로의 묵시적 형 변환 가능함
- 상속 관계에서 모든 하위 클래스느 상위 클래스로 형 변환(업캐스팅)이됨

## 21-매서드 재정의하기(overring)
### 1) 하위 클래스에서 메서드 재정의하기
1. 오버라이딩(overriding)
    - 상위 클래스에 정의된 메서도의 구현 내용이 하위 클래스에서 구현할 내용과 맞지 않는 경우 하위 클래스에서 동일한 이름 메서드 재정의 할 수 있음
    - 재정의해 구현해야함
2. @overriding 애노테이션
    - 애노테이션은 원래 주석이라는 의미
    - 컴파일러에게 특별한 정보를 제공해주는 역할
         애노테이션 | 설명 | 
        :---: | :--- |
        @Override | 재정의된 메서드라는 정보 제공
        @Fuctionallnterface | 함수형 인터페이스라는 정보 제공
        @Deprecated | 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨
        @SuppressWarnings | 특정 경고가 나타나지 않도록 함<br>(예) @SupperWarnings("deprecation")는<br>@Deprecated가 나타나지 않도록함

## 22-다형성
### 1) 특징
- 하나의 코드가 여러 자료형으로 구현돼 실행
- 같은 코드에서 여러 다른 실행 결과가 나옴
- 정보은닉, 상속과 더불어 객체지향 프로그래밍의 가장 큰 특징 중 하나임
- 다형성을 잘 활용하면 유연하고 확장성 있음
- 유지보수가 편리한 프로그램을 만들 수 있음
### 2) 사용하는 이유?
- 다른 동물을 추가하는 경우
- 상속과 메서드 재정의를 활용해 확장성 있는 프로그램을 만들 수 있음
- 그렇지 않을 경우 깊은 제어문이 구현되고 코드의 유지보수 어려움
- 상위 클래스에서는 공통적인 부분을 제공하고 하위 클래스에서는 각 클래스에 맞는 기능 구현
- 여러 클래스를 하나의 타입(상위 클래스)으로 핸들링 할 수 있음

## 23-다운 캐스팅 및 instanceof
### 1) 다운캐스팅 
- 업캐스팅된 클래스를 다시 원래의 타입으로 형 변환
- 하위 클래스로의 형 변환은 명시적으로 해야 함
### 2) instanceof를 이용해 인스턴스의 형체크 
- 원래 인스턴스의 형이 맞는지 여부를 체크하는 키워드 맞으면 true 아니면 false를 반환

## 24-추상 클래스
### 1) 특징
- 구현 코드 없이 메서드의 선안만 있느 추상메서드(abstract method)를 포함한 클래스
- 메서드 선언(declaration)
    - 반환타입, 메서드 이름, 매개변수로 구성
- 메서드 정의(definition)
    - 메서드 구현과 동일한 의미 구현부(body)를 가짐
- abstract 예약어를 사용
- 추상 클래스 new 할 수 없음(인스턴스화 안됨)
### 2) 구현
- 메서드에 구현 코드가 없으면 abstract로 선언
- abstract로 선언된 메서드를 가진 클래스는 abstract로 선언
- 모든 메서드가 구현 된 클래스라도 abstract로 선언되면 추상 클래스로 인스턴스화 할 수 없음
- 추상 클래시의 추상 메서드는 하위 클래스가 상속해 구현
- 추상 클래스 내의 추상 메서드:
    - 하위 클래스가 구현해야 하는 메서드
- 추상 클래스 내의 구현된 메서드 
    - 하위 클래스가 공통으로 사용하는 메서드(필요에 따라 하위 클래스에서 재정의 함)
### 3) 템플릿 메서드 패턴
- 추상 메서드나 구현된 메서드를 활용해 코드의 흐름을 정의하는 메서드
- final 선언해 하위 클래스에서 재정의 못함
- 프레임워크에서 주로 많이 쓰는 설계 패턴
- 추상 클래스로 선언된 상위 클래스에서 템플릿 메서드를 활용해 전체적인 흐름을 정의해 하위 클래스에서 다르게 구현되어야 하는 부분은 추상 메서드로 선언해 하위 클래스에서 구현

## 25-인터페이스
### 1) 특징
- 모든 메서드가 추상 메서드로 선언됨(public abstract)
- 모든 변수는 상수로 선언됨(public static final)
- 자바 8디폴트 메서드(default method)와 정적 메서드(static method) 기능의 제공으로 일부 구현 코드가 있음
- 자바 9 이후 private 메서드
    - 인터페이스를 구현한 클래스에서 사용하거나 재정의 할 수 없음
    - 인터페이스 내부에서만 사용하기 위해 구현하는 메서드
    - default 메서드나 static 메서드에서 사용함
### 2) 하는일
- 클래스나 프로그램이 제공하는 기능 명시적 선언
- 일종의 클라이언트 코드와의 약속
- 클래스나 프로그램이 제공하는 명세
- 클라이언트 프로그램은 인터페이스에 선언된 메서드 명세만 보고 이를 구현한 클래스를 사용할 수 있음
- 어떤 객체가 하나의 인터페이스 타입이라는 것은 그 인터페이스가 제공하는 모든 메서드를 구현 했다는 의미임 
- 인터페이스를 구현한 다양한 객체를 사용함
### 3) 다형성 
- 하나의 인터페이스를 여러 객체가 구현하게 되면 클라이언트 프로그램은 인터페이스의 메서드를 활용해 여러 객체의 구현을 사용할 수 있음
### 4) 여러 인터페이스 구현 
- 자바의 인터페이스는 구현 코드가 없어 하나의 클래스가 여러 인터페이스를 구현 할 수 있음
- 디볼트 메서드가 중복되는 경우 구현하는 클래스에서 재정의
- 여러 인터페이스를 구현한 클래스는 인터페이스 타입으로 형변환 되는 경우 해당 인터페이스에 선언된 메서드만 사용 가능
### 5) 인터페이스 상속
- 인터페이스 사이에도 상속을 사용 가능
- extends 키워드 사용
- 인터페이스는 다중 상속이 가능해 구현 코드의 상속이 아니므로 타입 상속이라고 함
### 6) 클래스 상속과 인터페이스 구현 함께 쓰기
- 실무에서 프레임워크나 오픈소스와 연동해서 사용 되는 케이스 많음

## 26-Object 클래스
### 1) java.lang 패키지
- 많이 사용하는 기본 클래스들이 속한 패키지
- String, Integer, Sysytem 등 
- 프로그래밍시 import 하지 않아도 자동으로 import됨
### 2) 모든 클래스는 object 클래스를 상속 받음
- 모든 클래스의 최상위 클래스
- 모든 클래스는 Object 상속받음 
- 클래스의 메서드 중 일부는 재정의해서 사용할 수 있음
- java.lang.Object
### 3) toString() 메서드
- 객체의 정보를 String으로 바꿔 사용할때 씀
- String이나 Interger 클래스는 이미 재정의 돼 있음
### 4) 메서드 활용 
1. equals()
    - 두 인스턴스의 주소 값을 비교해 true/false를 반환
    - 재정의해 두 인스턴스가 논리적으로 동일함의 여부 구현
    - 인스턴스가 다르더라도 논리적으로 동일한 경우 true 반환하도록 재정의 할 수 있음
2. hashCode()
    - hashCode() 인스턴스의 저장 주소를 반환함
    - 힙메모리에 인스턴스가 저장되는 방식 hash 방식
    - 자료의 특정 값(키 값)에 대한 저장 위치를 반환해주는 해시 함수를 사용
    - hash 
      - 정보를 저장, 검색하는 자료구조
3. clone()
    - 객체의 원본을 복제하는데 사용한 메서드
    - 생성과정의 복잡한 과정을 반복하지 않고 복제 할 수 있음
    - clone() 메서드를 사용해 객체의 정보가 동일한 또 다른 인스턴스가 생성됨
    - 객체 지향 프로그램에서의 정보은닉, 객체 보호의 관점에서 위배 될 수 있음
    - 해당 클래스의 clone() 메서드의 사용을 허용한다는 의미로 cloneable 인터페이스를 명시해 줌

## 27-String * 클래스
### 1) String
- 선언  
    ```java
    String abc = new String("abc");
    String abc = "abc";
    ```
- 힙 메모리에 인스턴슨로 생성되는 경우 상수 풀(constant pool)에 있는 주소를 참조하는 두가지 방법
- 힙 메모리는 생성될때마다 다른 주소 값을 가지지만, 상수 풀의 문자열은 모두 같은 주소 값을 가짐
- 한번 생성된 String은 불변
- String을 연결하면 기존의 String에 연결 되는 것이 아니며, 새로운 문자열이 생성됨
### 2) StringBulider, StringBuffer 활용
- 내부적으로 가변적인 char[]를 멤버 변수로 가짐
- 문자열을 여러번 연결해 변경할 때 사용하면 유용함
- 새로운 인스턴스 생성하지 않고 char[] 변경함
- StringBuffer는 멀티 쓰레드 프로그래밍에서 동기화를 보장
- 단일 쓰레드 프로그램에선 StringBuilder 사용을 권장
- toString() 메서드로 String 반환
### 3) text block
- java 13
- 문자열 """ """ 사이에 이어서 만들 수 있음
- html, json 문자열 만드는데 유용

## 28-자료구조
### 1) 특징
- 프로그램에서 사용한 데이터를 메모리 상에서 관리하는 여러 구현 방법
- 효율적인 자료구조가 성능 좋은 알고리즘 기반이됨
- 자료의 효율적인 관리는 프로그램의 수행속도와 밀접한 관련 있음
- 여러 자료구조 중에서 구현하려는 프로그램에 맞는 최적의 자료구조를 찾아야함
### 2) 종류
1. 배열(Array)
  - 선형으로 자료 관리
  - 정해진 크기의 메모리를 먼저 할당 받아 사용
  - 자료의 물리적 위치와 논리적 위치 동일함
2. 연결리스트(LinkedList)
  - 선형으로 자료 관리
  - 자료가 추가 될때마다 `메모리` 할당 받음
  - 자료는 링크로 연결됨
  - 자료의 물리적 위치와 논리적 위치가 다를 수 있음
3. 스택(Stack)
  - 가장 나중에 입력 된 자료가 가장 먼저 출력되는 자료구조(Last In First Out)
4. 큐(Queue) 
  - 가장 먼저 입력 된 자료가 가장 먼저 출력되는 자료구조(First In First Out)
5. 트리(Tree)
  - 부모 노드와 자식 노드 간의 연결로 이루어진 자료구조
6. 힙(heap)
  - Priority queue로 구현(우선순위 큐)
  - Max heap: 부모 노드는 자식 노드보다 항상 크거나 같은 값을 갖는 경우
  - Min heap: 부모 노드는 자식 노드보다 항상 작거나 같은 값을 갖는 경우
7. 이진트리(Binary tree)
  - 부모노드에 자식노드가 두 개 이하인 트리
8. 이진검색트리(Binary search tree)
  - 자료(key)의 중복 허용안함
  - 왼쪽 자식 노드는 부모 노드 보다 작은 값
  - 오른쪽 자식 노드는 부모 노드 보다 큰 값
  - 자료를 검색에 걸리는 시간이 평균 N(log(n))
9. 그래프(Graph)
  - 정점과 간선들의 유한집합
  - 정점(Vertex): 여러 특성을 가지는 객체, 노드(Node)
  - 간선(edge): 이 객체들을 연결 관계를 나타냄, 링크(Link)
  - 간선은 방향성이 있는 경우와 없는 경우가 있음
  - 구현방법: 인접행렬(adjacency matrix), 인접 리스트(adjacency list)
  - 탐색방법: BFS(bread first search), DFS(Depth frist search)
10. 해싱(hashing)
  - 자료를 검색하기 위한 자료구조
  - 키(Key)에 대한 자료를 검색하기 위한 사전 개념의 자료구조
  - key는 유일하고 이에 대한 value를 쌍으로 저장

## 29-제네릭
### 1) 특징
- 클래스에서 사용하는 변수의 자료형이 여러개 일때나, 그 기능은 동일한 경우 클래스의 자료형을 특정하지 않고 추후 해당 클래스를 사용할 때 지정 할 수 있도록 선언
- 실제 사용되는 자료형의 변환은 컴파일러에 의해 검증되므로 안정적인 프로그래밍 방식
- 컬렉션 프레임원크에서 많이 사용되고 있음
### 2) 사용 안할 경우
- Object 사용 후 형변환 해야함
### 3) 제네릭 클래스 정의
- 자료형 매개변수 T(type paramater)
    - 이 클래스를 사용한 시점에 실제 사용할 자료형을 지정
    - static 변수는 사용할 수 없음
- GenericPrinter: 제너릭 자료형
- E: element
- K: key
- V: value
- 여러 알파벳을 의미 따라 사용 가능
  ```java
  public class GenericPrinter<T> {
      private T material;

      public void setMaterial(T material){
          this.material = material;
      }

      public T getMaterial() {
          return material;
      }
      public String toString(){
          return material.toString();
      }
  }
  ```
### 4) \<T extends 클래스\> 사용하기
1. 상위 클래스의 필요성
    - T 자료형의 범위를 제한 할 수 있음
    - 상위 클래스에서 선언하거나 정의하는 메서드를 활용 할 수 있음
    - 상속을 받지 않은 경우 T는 Object로 변환돼 Object 클래스가 기본으로 제공하는 메서드만 사용가능
2. T extends를 사용한 프로그래밍
    - GenricPrinter에 material 변수의 자료형을 상속 받아 구현
    - T에 무작위 클래스가 들어갈 수 없게 Material 클래스를 상속 받은 클래스 한정
- 예제
  - [GenericPrinterTest](./code/GenericPrinterTest.java)
  - [GenericPrinter](./code/GenericPrinter.java)
  - [Plastic](./code/Plastic.java)
  - [Powder](./code/Powder.java)
  - [Material](./code/Material.java)
### 5) 제네릭 메서드 활용
- 자료형 매개변수를 메서드의 매개변수나 반환 값으로 가지는 메서드
- 자료형 매개변수가 하나 이상인 경우도 있음
- 제네릭 클래스가 아니어도 내부에 제네릭 메서드는 구현하여 사용 할 수 있음
- Public<자료형 매개변수> 반환형 메서드 이름(자료형 매개변수..){}

## 30-컬렉션 프레임워크
### 1) 특징
  - 자료구조를 구현해 놓은 JDK 라이브러리
  - java.util 패키지 구현어 있음
  - 개발에 소요되는 시간을 절약하면서 최적화된 알고리즘 사용할 수 있음
  - 여러 구현 클래스와 인터페이스의 활요에 대한 이해가 필요함
### 2) Collection 인터페이스
  - 하나의 객체를 관리하기 위한 메서드가 선언된 인터페이스
  - 하위 : List, Set 인터페이스 있음
### 3) List 인터페이스
  - 객체를 순서에 따라 저장하고 관리하는데 필요한 메서드가 선언된 인터페이스
  - 자료구조 리스트(배열, 연결리스트)의 구현을 위한 인터페이스
  - 중복을 허용함
  - ArrayList, Vector, LinkedList, Stack, Queue
### 4) Set 인터페이스
  - 순서와 관계없이 중복 허용안함
  - 유일한 값을 관리하는데 필요한 메서드가 선언됨
  - 아이디, 주민번호, 사번 등을 관리하는데 유용
  - 저장된 순서와 출력되는 순서가 다를 수 있음
  - HashSet, TreeSet 등
### 5) Map 인터페이스
  - 쌍(pair)로 이루어진 객체를 관리하는데 사용하는 메서드들이 선언된 인터페이스
  - 객체는 key-value의 쌍으로 이루어짐
  - key는 중복을 허용하지 않음
  - HashTable, HashMap, Properties, TreeMap 등이 Map 인터페이스를 구현함
### 6) Iterator 
  - 컬렉션 프레임워크에 저장된 요소들을 하나씩 차례로 참조하는 것
  - 순서가 있는 List인터페이스의 경우는 Iterator를 사용하지 않고 get(i) 메서드를 활용할 수 있음
  - Set 인터페이스의 경우 get(i) 메서드가 제공되지 않으므로 Iterator를 활용해 객체를 순회함
### 7) TreeSet
  - 객체의 정렬에 사용하는 클래스
  - Set인터페이스를 구현하여 중복을 허용하지 않음
  - 오름차순이나 내림차순으로 객체를 정렬할 수 있음
  - 내부적으로 이진검색트리(binary search tree)로 구현됨
  - 이진검색트리에 저장하기 위해 각 객체를 비교해야함
  - 비교 대상이 되는 객체에 Comparable이나 Comparator 인터페이스를 구현해야

## 31-내부클래스
### 1) 특징
- 클래스 내부에 선언한 클래스로 이 클래스를 감싸고 있는 외부 클래스와 밀접한 연관 있는 경우가 많음
- 다른 외부 클래스에서 사용할 일이 거의 없는 경우에 내부 클래스로 선언해서 사용함
- 중첩 클래스라고도 함
- 내부 클래스의 종류
### 2) 인스턴스 내부 클래스
- 내부적으로 사용할 클래스를 선언(private으로 선언하는 것을 권장)
- 외부 클래스가 생성된 후 생성된(정적 내부 클래스와 다름)
- private이 아닌 내부 클래스는 다른 외부 클래스에서 생성할 수 있음
### 3) 정적 내부 클래스
- 외부 클래스 생성과 무관하게 사용 할 수 있음
- 정적 변수, 정적메서드 사용

정적 내부 클래스 메서드 | 변수 유형 | 사용 가능 여부 
--- | --- |---
| |외부 클래스의 인스턴스 변수(num)  | x 
일반 메서드| 외부 클래스의 정적 변수(snum) | O
void in test() | 정적 내부 클래스의 인스턴스(inNum) | O
|| 정적 내부클래스의 정적 변수(slnNum) | O
|| 외부 클래스의 인스턴스 변수(num) | X
정적 메서드 | 외부 클래스의 정적변수(snum) | O
static void sTest()| 정적 내부 클래스의 인스턴스 변수(inNum) | X
|| 정적 내부 클래스의 정적 변수(slnNum) | O

### 4) 지역 내부 클래스
- 지역 변수와 같이 메서드 내부에서 정의해 사용하는 클래스
- 메서드의 호출이 끝나면 메서드에 사용된 지역변수의 유효성은 사라짐
- 메서드 호출 이후에도 사용해야 하는 경우가 있을 수 있으므로 지역 변수나 매개 변수는 final로 선언됨
### 5) 익명 내부 클래스
- 이름이 없는 클래스(위 지역 내부 클래스의 MyRunnable 클래스 이름은 실제로 호출되는 경우가 없음)
- 클래스 이름을 생략하고 주로 하나의 인터페이스나 하나의 추상 클래스를 구현해 반환
- 인터페이스나 추상 클래스 자료형의 변수에 직접 대입해 클래스를 생성하거나 지역 내부 클래스의 메서드 내부에서 생성하여 반환 할 수 있음.

## 32-람다식
### 1) 특징
- 자바 8부터 함수형 프로그래밍 방식을 지원함
- 함수의 구현과 호출만드로 프로그래밍이 수행되는 방식
### 2) 문법
- 익명 함수 만들기
- 매개 변수와 매개변수를 이용한 실행문
- (매개변수) -> {실행문;}
  1. 람다 표현식
    - (int x, int y) -> {return x+y;}
  2. 매개 변수가 하나인 경우 자료형과 괄호 생략가능
    - str ->{System.out.println(x+y)}
  3. 매개변수가 두 개 이상인 경우 괄호를 생략할 수 없음
    - x,y -> {System.out.println(x+y)}
  4. 실행문이 한 문장인 경우 중괄호 생략 가능
    - ste -> System.out.println(str)
  5. 실행문이 한 문장이라도 retrun문(반환문)은 중괄호를 `생략할 수 없음`
    - str -> return str.lenght(); 
  6. 실행문이 한 문장의 반환문인 경우엔 return과 중괄호를 모두 생략
    - (x,y) -> x+y;
    - str -> str.lenght;
### 3) 함수형 인터페이스와 사용
- 람다식을 선언하기 위한 인터페이스
- 익명 함수와 매개 변수만으로 구현됨
- 인터페이스는 단 하나의 메서드만 선언해야함
- @Functionallnterface 애노테이션(annotation)
  - 함수형 인터페이스라는 의미
  - 내부에 여러 개의 메서드 선언하면 에러남

## 33-예외처리
### 1) 프로그램 오류
1. 컴파일 오류(compile error)
    - 프로그램 코드 작성 중 발생하는 문법적 오류
    - 최근에는 개발환경에서 대부분 컴파일 오류는 detection됨
2. 실행오류(runtime error)
    - 실행 중인 프로그램이 의도 하지 않은 동작(bug)을 하거나 프로그램이 중지 되는 오류
    - 실행 오류는 비정상 종료가 되는 경우 시스템의 심각한 장애를 발생할 수 있음
### 2) 예외 처리의 중요성
- 프로그램의 비정상 종료를 피해 시스템이 원할이 실행되도록함
- 실행 오류가 발생한 경우 오류의 과정을 재현하는 것은 현실적으로 힘듬
- 오류가 발생한 경우 log를 남겨서 추후 log 분석을 통해 그 원인을 파악해 bug를 수정하는 것이 중요
### 3) 오류와 예외 클래스
- 시스템 오류(error)
  - 가상 머신에서 발생, 프로그래머가 처리 할 수 없는 오류
  - 동적 메모리가 없는 경우, 스택 메모리 오버플로우 등
- 예외(Exception)
  - 프로그램에서 제어 할 수 있는 오류
  - 읽어들이려는 파일이 존재하지 않거나
  - 네트워크 DB연결이 안되는 경우
- 자바는 안정성이 중요한 언어로 대부분 프로그램에서 발생한 오류에 대해 문법적으로 예외 처리를 해야함
### 4) 예외 클래스들
- 모든 예외 클래스의 최상위 클래스 `Excetption`클래스
- 자바에서는 다양한 예외들에 대해 그 처리를 위한 클래스가 제공되고 있음
- Arithmetic Exception: 정수를 0으로 나눈 경우 발생
- NullPointException: 초기화 되지 않은 Object를 사용하는 경우
- ArrayIndexOutOfBoundsException: 배열의 크기를 넘어선 위치를 참조 할때
- FileNotFoundException: 참조하는 파일이 지정된 위치에 존재하지 않는 경우
- ClassNotFoundException: 클래스가 로드되지 않은 경우
- InterruptedException: Thread.sleep(),join Object의 wait()로 non-runnable 상태인 thread를 Runnable하게 만들 수 있도록 사용 할 수 있음
### 5) try-catch
- try 블록에는 예외가 발생할 가능성이 있는 코드 작성
- try 블록 안에서 예외가 발생하면 catch 블록이 수행됨
  ```java
  try{
    예외가 발생할 수 있는 코드 부분
  } catch(처리할 예외 타입 e){
    try 블록 안에서 예외가 발생했을 때 
    예외를 처리하는 부분
  }
  ```
### 6) try-catch-finally
- finally 블럭에서 파일을 닫거나 네트워크를 닫는 등의 리소스 해제 구현
- try{} 블럭이 수행되는 경우, finally{}
- 여러 개의 예외 블럭이 있는 경우 각각에서 리소를 해제하지 않고 finally 블록에서 해제하도록 구현함
### 7) try-with-resource
- 리소스를 사용한 경우 close() 하지 않아도 자동으로 해제됨
- 자바 7부터 제공
- 리소스를 try() 내부에서 선언해야만 함
- close)() 명시적으로 호출하지 않아도 try{}블록에서 열린 리소스는 정상적인 경우나 예외가 발생한 경우 모두 자동으로 해제됨
- 해당 리소스 클래스가 AutoCloseable을 구현함
- FileInputStream의 경우엔 AutoCloseable을 구현하고 있음
- 자바 9부터 리소스 try() 외부에서 선언하고 변수만을 try(obj)와 같이 사용할 수 있음
### 8) 예외 처리 미루기
- 예외 처리는 예외가 발생하는 문장에서 try-catch 블록으로 처리하는 방법과 이를 사용하는 부분에서 처리하는 방법 두 가지가 있음
- throw를 이용하면 예외가 발생할 수 있는 부분을 사용하는 문장에서 예외를 처리할 수 있음
### 9) 하나의 try{} 블록에서 예외가 여러개 발생
- 여러개의 예외가 발생하는 경우 예외를 묶어서 하나의 방법으로 처리
- 각각의 예외를 따로 처리 할 수도 있음
- Exception 클래스를 활용해 default 처리를 할때 Exception 블록은 맨 마지막에 위치해야함
### 10) 사용자 정의 예외 클래스
- 자바에서 제공되는 예외 클래스외에 프로그래머가 직접 만들어야 하는 예외가 있을 수 있음
- 기존 예외 클래스 중 가장 유사한 예외 클래스에서 상속 받아 사용자 정의 예외 클래스를 만듬
- 기본적 Exception 클래스를 상속해서 만들 수 있음
### 11) 로그남기기
1. logging
  - 시스템 운영에 대한 기록
  - 오류가 발생 했을 때 그 오류에 대한 기록을 남겨 디버깅을 용이하게 함
  - 로그 파일에 기록하는 코드를 추가해 필요한 정보가 로그로 남을 수 있도록 함
  - 디버깅, 시스템 에러 추적, 성능, 문제점 향상들을 위해 사용
  - 어느정도까지 남길 것인가?
    - 작을 경우: 정확한 시스템의 상황을 파악하기 어려움
    - 많을 경우: 빈번한 file I/O의 오버헤드와 로그 파일의 백업 문제 발생
2. java.util.logging
  - 자바에서 기본적으로 제공되는 log package
  - 파일이나 콘솔에 로그 내용을 출력할 수 있음
  - jre/lib/logging.properties 파일을 편집해 로그의 출력방식 로그 레벨을 변경 가능
  - loggin 패키지에서 제공하는 로그레벨은 severe, warning, info, config, fine, finer,finest
  - 오픈소스로는 log4j를 많이 사용함

## 34-I/O 스트림
### 1) 특징
- 네트워크에서 자료의 흐름이 물의 흐름과 같다는 비유에서 유래됨
- 자바는 다양한 입출력 장치에 독립적으로 일관성 있는 입출력을 입출력 스트림을 통해 제공
- 입출력 구현되는 곳: 파일 디스크, 키보드 마우스, 메모리등 모든 자료가 입출력되고 출력되는 곳
### 2) 대상 구분
1. 입력 스트림
   - 대상으로 부터 자료를 읽어 들이는 스트림
   - FileInputStream, FileReader, BuffereInPutStream, BufferedReader 등
2.  출력 스트림
   - 대상으로 자료를 출력하는 스트림
   - FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등
### 3) 자료 구분
1. 바이트 스트림
  - 동영상, 음악파일, 실행 파일 등의 자료를 읽고 쓸 때 사용
  - FileInputStream, FileOupStream, BufferedInputStream, BufferedOutputStream
2. 문자 스트림
  - 바이트 단위로 자료를 처리하면 문자는 깨짐
  - 인코딩에 맞게 2바이트 이상으로 처리하도록 구현된 스트림
  - FileReader, FileWriter, BufferedReader,BufferedWriter
### 4) 기능 구분
1. 기반 스트림
  - 대상에 직접 자료를 읽고 쓰는 기능의 스트림
  - FileInputStream, FileOutStream, FileReader, FileWriter 
2. 보조 스트림
  - 직접 읽고 쓰는 기능은 없이 추가적인 기능을 더해주는 스트림
  - 보조 스트림은 직접 읽고 쓰는 기능은 없으므로 항상 기반 스트림 또 다른 보조 스트림을 생성자의 매개변수로 포함함
  - InputStreamReader, OutputStreamWriter, BufferedInputStream, BufferedOutputStream

## 35-직렬화
### 1) 특징
- 인스터스의 상태를 그대로 파일 저장하거나 네트워크로 전송하고 이를 다시 복원 하는 방식
- 자바에서는 보조 스트림을 활용해 직렬화를 제공함
  | 생성자 | 설명|
  | --- | --- |
  ObjectInputStream(InputStream in) | InputStream을 생성자의 매개변수로 받아 ObjectInputStream을 생성
  ObjectOutputStream(OutputStream out) | OutputStream을 생성자의 매개변수로 받아 ObjectOutputStream을 생성

### 2) 인터페이스 
- 직렬화는 인스턴스의 내용이 외부로 유추되는 것이므로 프로그래머가 해당 객체에 대한 직렬화 의도를 표시해야함

## 36-입출력 클래스
### 1) File 클래스
- 파일 개념을 추상화한 클래스
- 입출력 기능은 없음
- 파일의 이름, 경로, 읽기 전용등의 속성을 알 수 있음

### 2) RandomAccessFile 클래스
- 입출력 클래스 중 유일하게 파일에 대한 입출력을 동시에함
- 파일 포인터가 있어서 읽고 쓰는 위치의 이동이 가능